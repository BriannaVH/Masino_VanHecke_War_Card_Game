<html>

<head>
    <title>WAR Card Game</title>
    <!-- Zara Masino & Brianna Van Hecke  -->
    <!-- For the "above and beyond" aspect, we did rect area lighting -->
</head>

<body>

    <canvas id="myCanvas" width="1650" height="700"></canvas>
    <script type="module">

        // NOTE: FUNKY STUFF WHEN WAR AND SOMEONE HAS 1 CARD LEFT, GET ALLOCATED TO WINNER WITHOUT PLACING

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { RectAreaLight } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/src/lights/RectAreaLight.js";

        //Variable declaration
        var scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let deck = [];
        let players = [];
        let tableMesh;
        let floorMesh;
        //Position for each player position
        let leftMid = new THREE.Vector3(-1.15, 0, 0);
        let rightMid = new THREE.Vector3(1.15, 0, 0);
        let centerMid = new THREE.Vector3(0, 0, 0);
        let positions = [leftMid, centerMid, rightMid];
        let cardPlacement = .08;
        const width1 = 5;
        const height1 = 5;
        const intensity = 1;
        let movePermitted = true;
        var gameOver = false;
        let sky0 = false;
        const loader = new THREE.TextureLoader();

        let woodTexture = 'misc_textures/table.jpg';
        let backOfCard = 'misc_textures/card_back.png';

        //Creates two textured materials for the horizons
        let skies = [
            new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky0.png'), side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky2.jpg'), side: THREE.DoubleSide })
        ];
        //Creates arrays of relative paths to each corresponding texture for each suit 
        let clubs = ['card_Textures/2_of_clubs.png', 'card_Textures/3_of_clubs.png', 'card_Textures/4_of_clubs.png', 'card_Textures/5_of_clubs.png',
            'card_Textures/6_of_clubs.png', 'card_Textures/7_of_clubs.png', 'card_Textures/8_of_clubs.png', 'card_Textures/9_of_clubs.png',
            'card_Textures/10_of_clubs.png', 'card_Textures/jack_of_clubs2.png', 'card_Textures/queen_of_clubs2.png',
            'card_Textures/king_of_clubs2.png', 'card_Textures/ace_of_clubs.png'];

        let hearts = ['card_Textures/2_of_hearts.png', 'card_Textures/3_of_hearts.png', 'card_Textures/4_of_hearts.png', 'card_Textures/5_of_hearts.png',
            'card_Textures/6_of_hearts.png', 'card_Textures/7_of_hearts.png', 'card_Textures/8_of_hearts.png', 'card_Textures/9_of_hearts.png',
            'card_Textures/10_of_hearts.png', 'card_Textures/jack_of_hearts2.png', 'card_Textures/queen_of_hearts2.png', 'card_Textures/king_of_hearts2.png',
            'card_Textures/ace_of_hearts.png'];

        let diamonds = ['card_Textures/2_of_diamonds.png', 'card_Textures/3_of_diamonds.png', 'card_Textures/4_of_diamonds.png',
            'card_Textures/5_of_diamonds.png', 'card_Textures/6_of_diamonds.png', 'card_Textures/7_of_diamonds.png', 'card_Textures/8_of_diamonds.png', 'card_Textures/9_of_diamonds.png',
            'card_Textures/10_of_diamonds.png', 'card_Textures/jack_of_diamonds2.png', 'card_Textures/queen_of_diamonds2.png', 'card_Textures/king_of_diamonds2.png',
            'card_Textures/ace_of_diamonds.png'];

        let spades = ['card_Textures/2_of_spades.png', 'card_Textures/3_of_spades.png', 'card_Textures/4_of_spades.png',
            'card_Textures/5_of_spades.png', 'card_Textures/6_of_spades.png', 'card_Textures/7_of_spades.png', 'card_Textures/8_of_spades.png',
            'card_Textures/9_of_spades.png', 'card_Textures/10_of_spades.png', 'card_Textures/jack_of_spades2.png', 'card_Textures/queen_of_spades2.png', 'card_Textures/king_of_spades2.png',
            'card_Textures/ace_of_spades.png'];


        //Creates camera and positions camera for "intelligent positioning"
        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.x = 0;
        camera.position.y = 2.5;
        camera.position.z = 4;

        //Creates renderer for the canvas
        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        //Creates a lookat For the camera
        var focal = new THREE.Vector3(0.0, 0.0, 0.0);

        renderer.shadowMap.enabled = true; //Enables the shadow map on the renderer
        camera.lookAt(focal);//Sets the camera's look at to the origin
        scene.add(camera);//Adds the camera to the scene

        //Creates Ambient light and adds it to the scene
        const ambientLight = new THREE.AmbientLight(0xFFB6C1, .5);
        scene.add(ambientLight);

        //Src : https://threejs.org/examples/?q=light#webgl_lights_physical
        //Creates a sphere 
        const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
        let bulbLight = new THREE.PointLight(0xffee88, 1.5, 100, 2);
        let bulbMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: 1,
            color: 0x000000
        });
        bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
        bulbLight.position.set(0, 2.0, -2);
        bulbLight.castShadow = true;
        scene.add(bulbLight);

        const rectLight = new THREE.RectAreaLight(0xADD8E6, intensity, width1, height1);
        rectLight.position.set(0, 0, -1.6);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        // left player 0, middle player 1. right player 2, we are player 1 in the middle
        // a function that shuffles the cards 
        // Src: https://dev.to/codebubb/how-to-shuffle-an-array-in-javascript-2ikj#:~:text=The%20first%20and%20simplest%20way,)%20%3D%3E%200.5%20%2D%20Math. 
        const shuffleArray = deck => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = deck[i];
                deck[i] = deck[j];
                deck[j] = temp;
            }
        }

        function Player(playerID, playerPosition) {
            this.cardsLeft = true;
            this.player = playerID;
            this.playerDeck = [];
            this.playing = true;
            this.currentCards = [];
            this.playerPos = playerPosition;
        }

        function Card(value, suit) {
            //Suit:
            //1 -- Spade
            //2 -- Hearts
            //3 -- Clubs
            //4 -- Diamonds
            this.cardValue = value;
            this.cardSuit = suit;

            this.geometry = new THREE.BoxGeometry(.3, .01, .6);
            this.material = makeMaterial(this.cardValue, this.cardSuit);

            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.rotation.x = 0;
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = true;
            this.mesh.translateY(5);

            scene.add(this.mesh);
        }

        function makeMaterial(value, suit) {
            const materials = [
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ map: loader.load(backOfCard) }), //this is back of the card
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }), //this is the front of the card
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
            ];
            let index = value - 1;
            let string;
            let material;
            if (suit == 1) { //Spade
                string = spades[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 2) { //Hearts
                string = hearts[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 3) { //Clubs
                string = clubs[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 4) { //Diamonds
                string = diamonds[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            return materials;
        }

        function initPlayers(number) {
            let player;
            for (let i = 0; i < number; i++) {
                player = new Player(i, positions[i]);
                players.push(player);
            }
        }

        // a function that create all 52 cards
        function initCards() {
            let card;
            // from 1 to 13
            for (let i = 1; i <= 13; i++) {
                // create a new card with i as the value and 1 as the suit (spade)
                card = new Card(i, 1);
                // push the card to the deck
                deck.push(card);
            }
            // from 1 to 13
            for (let i = 1; i <= 13; i++) {
                // create a new card with i as the value and 2 as the suit (hearts)
                card = new Card(i, 2);
                deck.push(card);
            }
            // from 1 to 13
            for (let i = 1; i <= 13; i++) {
                  // create a new card with i as the value and 3 as the suit (clubs)
                card = new Card(i, 3);
                deck.push(card);
            }
            // from 1 to 13
            for (let i = 1; i <= 13; i++) {
                // create a new card with i as the value and 4 as the suit (diamonds)
                card = new Card(i, 4);
                deck.push(card);
            }
        }

        function initTable() {
            let string1 = 'misc_texures/table.png';
            let geometry = new THREE.BoxGeometry(3, .15, 3);
            let material = new THREE.MeshPhysicalMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(woodTexture),

            });
            tableMesh = new THREE.Mesh(geometry, material);
            tableMesh.receiveShadow = true;
            tableMesh.castShadow = true;

            scene.add(tableMesh);
        }

        function initGround() {
            let string1 = 'floor/floor7.jpg';
            let geometry = new THREE.BoxGeometry(.01, 20, 20);

            let grounds = [
                new THREE.MeshPhysicalMaterial({ map: loader.load(string1) }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }), //this is the front
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }), //this is the back of the card
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
            ];
            floorMesh = new THREE.Mesh(geometry, grounds);
            floorMesh.receiveShadow = true;
            floorMesh.castShadow = true;
            floorMesh.position.set(0, -3, -5);
            floorMesh.rotateZ(Math.PI / 2);
            camera.lookAt(floorMesh.position.x, floorMesh.position.y, floorMesh.position.z);

            scene.add(floorMesh);
        }

        function initHorizon() {
            let planeGeometry = new THREE.PlaneGeometry(2.5, 1.5);
            let planeMaterial = skies[1];
            let planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            planeMesh.position.set(0, .80, -1.7);
            scene.add(planeMesh);
            return planeMesh;
        }

        function initWall() {
            let wallPaperGeometry = new THREE.BoxGeometry(20, 5, 1);
            let wallPaperMaterial = new THREE.MeshPhysicalMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            let wallPaperMesh = new THREE.Mesh(wallPaperGeometry, wallPaperMaterial);
            wallPaperMesh.position.set(0, -3, -8);
            scene.add(wallPaperMesh);
        }

        // a function that distributes the cards to each of the players
        function dealCards(deck, players) {
            // shuffle the deck
            shuffleArray(deck);
            // for each card in the deck
            for (let i = 0; i < deck.length; i++) {
                // give the first 17 cards to player 0
                if (i <= 17) {
                    players[0].playerDeck.push(deck[i]);
                }
                // give the next 17 to player 1
                else if (17 < i && i <= 34) {
                    players[1].playerDeck.push(deck[i]);
                }
                // give the final 18 cards to player 2
                else if (i > 34) {
                    players[2].playerDeck.push(deck[i]);
                }
            }
            // rotate the cards so that they are facedown on the table
            setOriginPosition(players);
            // place the cards in a stack in front of the player they belong to
            placeCards(players);
        }

        // a function that places the cards in a pile for each player
        function placeCards(players) {
            let playerX;
            let playerY;
            let playerZ;
            // for every player
            for (let i = 0; i < players.length; i++) {
                // set the beginning card height
                let height = .075;
                // for every card in the player's deck 
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    // add .013 to the height get that players x, y, and z coordinates
                    height += .013;
                    playerX = players[i].playerPos.x;
                    playerY = players[i].playerPos.y;
                    playerZ = players[i].playerPos.z;
                    // place the cards at the player's x y + height, and z coordinates
                    players[i].playerDeck[x].mesh.position.set(playerX, playerY + height, playerZ);
                }
            }
        }

        // a function that reorients the cards for each player
        function setOriginPosition(players) {
            // for every player
            for (let i = 0; i < players.length; i++) {
                // for every card in the player's deck
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    // set the cards rotation for every axis to 0
                    players[i].playerDeck[x].mesh.rotation.x = 0;
                    players[i].playerDeck[x].mesh.rotation.y = 0;
                    players[i].playerDeck[x].mesh.rotation.z = 0;
                }
            }
        }

        // a function used to create and track promises for the animation given the milliseconds to wait
        //Src: https://alvarotrigo.com/blog/wait-1-second-javascript/
        function delay(milliseconds) {
            // return a promise that resolves at the given number of milliseconds
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        }

        // a function that starts off a move 
        // given the players and if it is a normal or war movement
        function regularMove(players, warTime) {
            console.log("START REG MOVE");
            // get the cards that are being used in the current move
            let cardsInPlay = getCardsInPlay(players);
            // start off the animation with moveUp
            moveUp(cardsInPlay, warTime);
        }

        // a function that moves the cards up
        // given the current cards and if it is a normal or war movement
        //Src: https://alvarotrigo.com/blog/wait-1-second-javascript/
        async function moveUp(cards, warTime) {
            // for every current card
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE UP");
                // store that card
                let card = cards[c];
                // while that cards y coordinate is less than or equal to .75
                while (card.mesh.position.y <= .75) {
                    // set a 30 millisecond delay
                    await delay(30);
                    // translate the card .05 in the y direction
                    card.mesh.translateY(.05); //.01
                }
                // to counter slight variations, set the card's y coordinate to exactly .75
                card.mesh.position.y = .75;
            }
            // call the flip animation now that the card has moved all the way up
            flip(cards, warTime);
        }

        // a function that flips the cards over
        // given the current cards and if it is a normal or war movement
        async function flip(cards, warTime) {
            // if it is not a war movement
            if (warTime == false) {
                // for every current card
                for (let c = 0; c < cards.length; c++) {
                    console.log("START FLIP");
                    // store the card and declare counter i
                    let card = cards[c];
                    let i = 0;
                    // while i is less than 15
                    while (i < 15) { 
                        // set a 15 millisecond delay
                        await delay(15);
                        // rotate the card -.21 on the z axis
                        card.mesh.rotateZ(-.21); 
                        // increment i
                        i++;
                    }
                    // to counter slight variations, set the z rotation to exactly -3.15
                    card.mesh.rotation.z = -3.15;
                }
            }
            // call the move forward animation
            moveForward(cards, warTime);
        }

        // a function that moves the cards forward
        // given the current cards and if it is a normal or war movement
        async function moveForward(cards, warTime) {
            console.log("OH NO MY BOOLEAN ", warTime);
            // for every card
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE FORWARD");
                // store the card
                let card = cards[c];
                // while the card z position is less than or equal to .8
                while (card.mesh.position.z <= .8) {
                    // set a 25 millisecond delay
                    await delay(25);
                    // translate the .05 in the z direction
                    card.mesh.translateZ(.05);
                }
            }
            // call the move down animation
            moveDown(cards, warTime);
        }

        // a function that moves the cards down
        // given the current cards and if it is a normal or war movement
        async function moveDown(cards, warTime) {
            // for every card
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE DOWN");
                // store the card
                let card = cards[c];
                // while the card's y position is greater than or equal to the cardPlacement
                while (card.mesh.position.y >= cardPlacement) {
                    // set a 15 millisecond delay
                    await delay(15);
                    // if it is a regular move animation
                    if (warTime == false) {
                        // translate the card .02 is the y direction
                        card.mesh.translateY(.02);
                    }
                    // else (if it is a war animation)
                    else if (warTime == true) {
                        // translate the card -.02 in the y direction
                        card.mesh.translateY(-.02);
                    }
                }
                // to account for slight variation, set the card y position to cardPlacement
                card.mesh.position.y = cardPlacement;
            }
            // increment cardPlacement by .015
            cardPlacement += .015;
            console.log("animation done");

            // if this is a wartime animation
            if (warTime == true) {
                // move a card for each player
                moveOneCard(players);
                // move a card for each player
                moveOneCard(players);
                // call the initialization for the move with false for war animation
                regularMove(players, false);
            }
            // else if it is a normal animation
            else{
                // call the function that determines the outcome of the move given the current cards
                findWinOrWar(cards);
            }
        }

        // a function that determines the winner or signals that there is a war
        // given the cards to compare
        function findWinOrWar(cardsInPlay) {
            console.log("FIND RESULT");
            // set war to -10 and max to 0
            let wars = -10;
            let max = 0;
            // for every current card
            for (let y = 0; y < cardsInPlay.length; y++) {
                // if the card's value is equal to the max
                if (cardsInPlay[y].cardValue == max) {
                    console.log("equal");
                    // set wars equal to max since it is a pair of the highest value
                    wars = max;
                }
                // if the card's value is greater than max
                if (cardsInPlay[y].cardValue > max) {
                    console.log("greater");
                    // set max to that card's value
                    max = cardsInPlay[y].cardValue;
                }
            }
            // if max is equal to war (the pair is the highest value)
            if (max == wars) {
                console.log("INTOWAR");
                // if the player is still in the game
                if (checkPlayers(players) == true) {
                    // move one card for each player
                    moveOneCard(players);
                    // initiate a move with war being true
                    regularMove(players, true);
                }
            }
            // if there is no war
            else if (max != wars) {
                console.log("FIND WINNER ");
                console.log("MAX IS ????? ", max);
                let winner;
                // for each of the players
                for (let i = 0; i < players.length; i++) {
                    // if the player is still in the game
                    if (players[i].playing == true) {
                        console.log("all player cards ", players[i].currentCards);
                        // store the top card in the players current cards
                        let card = players[i].currentCards[0];
                        console.log("CARD???  ", card);
                        // if the card's value is the max value
                        if (card.cardValue == max) {
                            // set the winner to that player
                            winner = players[i];
                        }
                    }
                }
                // give the cards to the winner
                distributeWinnings(winner, players);
            }
        }

        // a function that checks if the players still have cards
        function checkPlayers(players) {
            console.log("CHECK PLAYERS FUNC");
            // initialize the count
            let count = 0;
            // for each player
            for (let i = 0; i < players.length; i++) {
                // if the player's deck is empty
                if (players[i].playerDeck.length == 0) {
                    // set the player'ss tatus to false (indicating they are out)
                    players[i].playing = false;
                    // if the player is out
                    if (players[i].playing == false) {
                        // increment the count
                        count++;
                    }
                }
            }
            // if the count is equal to 2, which means there is only one player left
            if (count == 2) {
                console.log("WINNER WINNER CHICKEN DINNER");
                // this can go when we are done with console.logs
                for (let i = 0; i < players.length; i++) {
                    console.log("deck at the end ", players[i].playerDeck);
                }
                // set gameOver to true
                gameOver = true;
                // return false
                return false;
            }
            // else if count is not equal to 2
            else {
                // return true
                return true;
            }
        }

        // a function that moves a card from each player's deck to their current playing cards
        function moveOneCard(players) {
            console.log("MOVE ONE CARD FUNC");
            // for each player
            for (let i = 0; i < players.length; i++) {
                // if the player is still in the game
                if (players[i].playing == true) {
                    // if the player is out of cards
                    if (players[i].playerDeck.length == 0) {
                        // set the player's playing status to false
                        players[i].playing = false;
                    }
                    // else if the player still has cards
                    else {
                        // pop a card off the player's deck
                        let topCard = players[i].playerDeck.pop();
                        // add the card to the beginning of the player's current cards
                        players[i].currentCards.unshift(topCard);
                    }
                }
            }
        }

        // a function that gets the cards to be compared
        function getCardsInPlay(players) {
            console.log("START GET CARDS");
            // create an array to store the current cards
            let cardsInPlay = [];
            // for each player
            for (let i = 0; i < players.length; i++) {
                // if the player is still in the game
                if (players[i].playing == true) {
                    // push the first card in the player's current cards to the array
                    cardsInPlay.push(players[i].currentCards[0]);
                    console.log("player current card ", players[i].currentCards[0]);
                }
            }
            // return the array of the cards to compare
            return cardsInPlay;
        }

        // a function to give the cards to the winner of a round
        function distributeWinnings(winner, players) {
            console.log("START DISTR WINNING");
            let spoils = [];
            // for each player
            for (let i = 0; i < players.length; i++) {
                // set spoils to the current winnings plus that player's cards
                spoils = spoils.concat(players[i].currentCards);
                // reset the player's current cards to empty
                players[i].currentCards = [];
            }
            console.log("spoils of war ", spoils);
            console.log("winner ", winner);
            // for each card in spoils
            for (let i = 0; i < spoils.length; i++) {
                // unshift the card to the winner's deck 
                winner.playerDeck.unshift(spoils[i]);
            }
            // set the permission to make a move to true
            movePermitted = true;
        }

        // a function to initialize a move
        function initMove(players) {
            console.log("HOT POTATO");
            // if at least 2 players are still in the game
            if (checkPlayers(players) == true) {
                // move one card to the current cards of each player
                moveOneCard(players);
                // initiate a regular move with war to false
                regularMove(players, false);
            }
        }

        // a function to set actions to keys
        function keyHandler(e) {
            switch (e.keyCode) {
                case 87: //w
                    // translate the pointlight -.1 in the z direction
                    bulbLight.translateZ(-.1);
                    break;
                case 83: //s
                    // translate the pointlight in the .1 direction
                    bulbLight.translateZ(.1);
                    break;
                case 68: //d
                    // translate the pointlight .1 in the x direction
                    bulbLight.translateX(.1);
                    break;
                case 65: //a
                    // translate the pointlight -.1 in the x direction 
                    bulbLight.translateX(-.1);
                    break;
                case 76: //L
                    // set the ambient light visibility to the opposite of it's current state
                    ambientLight.visible = !ambientLight.visible;
                    break;
                case 80: //P
                    // set the pointlight visibility to the opposite of it's current state
                    bulbLight.visible = !bulbLight.visible;
                    // set the pointlight position to it's starting position
                    bulbLight.position.set(0, .79, -2);
                    break;
                case 82: //R
                    // set the rectangle light visibility to the opposite of it's current state
                    rectLight.visible = !rectLight.visible;
                    break;
                case 77: //P
                    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
                    let enabled = renderer.shadowMap.enabled;

                    if (enabled == false) {
                        console.log("TURN OFF");
                        for (let i = 0; i < deck; i++) {
                            deck.mesh.castShadow = false;
                            deck.mesh.receiveShadow = false;
                        }
                        tableMesh.castShadow = false;
                        tableMesh.receiveShadow = false;
                        floorMesh.castShadow = false;
                        floorMesh.receiveShadow = false;
                    }
                    else {
                        console.log("TURN ON");
                        for (let i = 0; i < deck; i++) {
                            deck.mesh.castShadow = true;
                            deck.mesh.receiveShadow = true;
                        }
                        tableMesh.castShadow = true;
                        tableMesh.receiveShadow = true;
                        floorMesh.castShadow = true;
                        floorMesh.receiveShadow = true;
                    }
                    break;
                case 69:
                    // if sky0 is not the current window view
                    if (sky0 == false) {
                        // set the planemesh material to the first view in the skies
                        planeMesh.material = skies[0];
                        // set sky0 to true
                        sky0 = true;
                    }
                    // else if sky0 is the current window view
                    else {
                        // set the planemesh material to the second view in skies
                        planeMesh.material = skies[1];
                        // set sky0 to false
                        sky0 = false;
                    }
                    break;
                case 78:
                    // if the game is still in session
                    if (gameOver == false) {
                        // if the user is permitted to make a move
                        if (movePermitted == true) {
                            // set cardPlacement to .08
                            cardPlacement = .08;
                            // prevent users from making a move
                            movePermitted = false;
                            // place the cards for the players (clean up last turn's cards)
                            placeCards(players);
                            // set the cards orientations back
                            setOriginPosition(players);
                            // initialize a move
                            initMove(players);
                        }
                    }
                    break;
            }
        }

        // add the keyhandler to the document 
        document.addEventListener("keydown", keyHandler, false);

        function animate() {
            updateSize();
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        //Src: https://threejs.org/examples/webgl_multiple_views.html
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }

        initPlayers(3);
        initCards();
        initTable();
        initGround();
        initWall();
        let planeMesh = initHorizon();
        dealCards(deck, players);
        animate();
        renderer.render(scene, camera);

    </script>
</body>

</html>