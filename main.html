<html>

<head>
    <title>Three.js BuffedGeometry Example</title>
</head>

<body>

    <canvas id="myCanvas" width="1650" height="700"></canvas>


    <script type="module">

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";

        var scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let deck = [];
        let ambientLightOn = true;
        let pointLightOn = true;
        let leftMid = new THREE.Vector3(-1.25, 0, 0);
        let rightMid = new THREE.Vector3(1.25, 0, 0);
        let centerMid = new THREE.Vector3(0, -1.25, 0);
        let positions = [leftMid, centerMid, rightMid];
        var enableWar = 0;
        var gameOver = false;
        let shadowCamera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        let toggleUp, toggleRotate, toggleMoveForward, toggleDown = false;



        //left player 0, middle player 1. right player 2, we are player 1 in the middle

        const shuffleArray = deck => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = deck[i];
                deck[i] = deck[j];
                deck[j] = temp;
            }
        }




        let woodTexture = 'misc_textures/table.jpg';

        let backOfCard = 'misc_textures/card_back.png';

        let clubs = ['card_Textures/ace_of_clubs.png', 'card_Textures/2_of_clubs.png', 'card_Textures/3_of_clubs.png', 'card_Textures/4_of_clubs.png', 'card_Textures/5_of_clubs.png',
            'card_Textures/6_of_clubs.png', 'card_Textures/7_of_clubs.png', 'card_Textures/8_of_clubs.png', 'card_Textures/9_of_clubs.png',
            'card_Textures/10_of_clubs.png', 'card_Textures/jack_of_clubs2.png', 'card_Textures/queen_of_clubs2.png',
            'card_Textures/king_of_clubs2.png'];

        let hearts = ['card_Textures/ace_of_hearts.png', 'card_Textures/2_of_hearts.png', 'card_Textures/3_of_hearts.png', 'card_Textures/4_of_hearts.png', 'card_Textures/5_of_hearts.png',
            'card_Textures/6_of_hearts.png', 'card_Textures/7_of_hearts.png', 'card_Textures/8_of_hearts.png', 'card_Textures/9_of_hearts.png',
            'card_Textures/10_of_hearts.png', 'card_Textures/jack_of_hearts2.png', 'card_Textures/queen_of_hearts2.png', 'card_Textures/king_of_hearts2.png'];


        let diamonds = ['card_Textures/ace_of_diamonds.png', 'card_Textures/2_of_diamonds.png', 'card_Textures/3_of_diamonds.png', 'card_Textures/4_of_diamonds.png',
            'card_Textures/5_of_diamonds.png', 'card_Textures/6_of_diamonds.png', 'card_Textures/7_of_diamonds.png', 'card_Textures/8_of_diamonds.png', 'card_Textures/9_of_diamonds.png',
            'card_Textures/10_of_diamonds.png', 'card_Textures/jack_of_diamonds2.png', 'card_Textures/queen_of_diamonds2.png', 'card_Textures/king_of_diamonds2.png'];


        let spades = ['card_Textures/ace_of_spades.png', 'card_Textures/2_of_spades.png', 'card_Textures/3_of_spades.png', 'card_Textures/4_of_spades.png',
            'card_Textures/5_of_spades.png', 'card_Textures/6_of_spades.png', 'card_Textures/7_of_spades.png', 'card_Textures/8_of_spades.png',
            'card_Textures/9_of_spades.png', 'card_Textures/10_of_spades.png', 'card_Textures/jack_of_spades2.png', 'card_Textures/queen_of_spades2.png', 'card_Textures/king_of_spades2.png'];

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.x = 0;  // Try moving this around!
        camera.position.y = -4;
        camera.position.z = 2;  // Try moving this around!
        // camera.position.x = 0;  // There are our camera positions
        // camera.position.y = -4;
        // camera.position.z = 2;  // Try moving this around!
        var focal = new THREE.Vector3(0.0, 0.0, 0.0);
        camera.lookAt(focal);
        scene.add(camera);

  





       // #FFC0CB
       //0x0000ff
        const light = new THREE.AmbientLight(0xFF66CC, 1); // soft white light
        scene.add(light);


        // const plight = new THREE.PointLight(0xa0adaf, 100, 100);
        // plight.position.set(0, 0, 0);
        // scene.add(plight);


        // const sphereSize = 1;
        // const pointLightHelper = new THREE.PointLightHelper(plight, sphereSize);
        // scene.add(pointLightHelper);

        // plight.add(mesh);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //Sets the size of the renderer to the entirety of the



        const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
        // bulbGeometry.position.set(3,0,0);
        let bulbLight = new THREE.PointLight(0xffee88, 1.5, 100, 2);

        let bulbMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: 1,
            color: 0x000000
        });
        bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
        bulbLight.position.set(0, -.79, 2);
        bulbLight.castShadow = true;
        scene.add(bulbLight);

        shadowCamera.position.x = bulbLight.position.x;
        shadowCamera.position.y = bulbLight.position.y;
        shadowCamera.position.z = bulbLight.position.z;
        console.log(shadowCamera.position);
        // console.log(bulbLight);
        // const geometry = new THREE.BoxGeometry(1, 1, 1);
        // //const material = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
        // var loader = new THREE.TextureLoader();
        // const material = new THREE.MeshBasicMaterial({
        //   // Use the map attribute to hold the texture
        //   map: loader.load("whiteMarble.jpg"),
        // });
        // const plane = new THREE.Mesh(geometry, material);
        // scene.add(plane);

        const loader = new THREE.TextureLoader();

        const geometry = new THREE.BoxGeometry(.2, .01, .4);

        let i = 0;

        const materials = [

            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
            new THREE.MeshBasicMaterial({ map: loader.load(diamonds[2]) }), //this is the front
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }), //this is the back of the card
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
        ];

        const testCard = new THREE.Mesh(geometry, materials);
        //scene.add(testCard);
        //testCard.rotateX(1);


        let players = [];
        let checkPlayerDecks = [];

        function Player(playerID, playerPosition) {
            this.player = playerID;
            this.playerDeck = [];
            this.playing = true;
            this.currentCards = [];
            this.playerPos = playerPosition;
        }

        function Card(value, suit) {
            //Suit:
            //1 -- Spade
            //2 -- Hearts
            //3 -- Clubs
            //4 -- Diamonds
            this.cardValue = value;
            this.cardSuit = suit;

            this.geometry = new THREE.BoxGeometry(.2, .01, .4);
            this.material = makeMaterial(this.cardValue, this.cardSuit);

            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.rotation.x = Math.PI / 2;
            this.mesh.translateY(5);

            scene.add(this.mesh);
        }

        function makeMaterial(value, suit) {
            const materials = [

                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ map: loader.load(backOfCard) }), //this is the front
                new THREE.MeshPhongMaterial({ map: loader.load(backOfCard) }), //this is the back of the card
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
            ];

            let index = value - 1;
            let string;
            let material;

            if (suit == 1) { //Spade
                string = spades[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 2) { //Hearts
                string = hearts[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 3) { //Clubs
                string = clubs[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 4) { //Diamonds
                string = diamonds[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            //console.log(material);
            return materials;
        }

        function initCards() {
            let card;

            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 1);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 2);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 3);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 4);
                deck.push(card);
            }

            // console.log(deck);
            //testing
            // for (let i = 0; i < deck.length; i++) {
            //    // console.log("i", i);
            //     //console.log(deck[i].mesh);
            //     deck[i].mesh.rotateX(Math.random());
            //     deck[i].mesh.rotateY(Math.random());
            //     deck[i].mesh.rotateZ(Math.random());
            //     deck[i].mesh.translateX(Math.random());
            //     deck[i].mesh.translateY(Math.random());
            // }
        }




        function initPlayers(number) {
            let player;
            for (let i = 0; i < number; i++) {
                player = new Player(i, positions[i]);
                players.push(player);
            }
            checkPlayerDecks = players;
        }

        function testShape() {
            let geom = new THREE.BoxGeometry(.25, .25, .25);
            let material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            let mesh = new THREE.Mesh(geom, material);
            scene.add(mesh);
            return mesh;
        }


        function initTable() {
            let string1 = 'floor/floor2.png';
            let geometry = new THREE.BoxGeometry(3, 3, .15);
            let material = new THREE.MeshPhongMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(woodTexture),
            });

            let mesh = new THREE.Mesh(geometry, material);
            //mesh.translateZ(-1);

            //     let testLeft = testShape();
            //     let testRight = testShape();
            //     let testCenter = testShape();


            //     testLeft.translateX(-1.25);
            //     testRight.translateX(1.25);
            //     testCenter.translateY(-1.25);

            //    // testCenter.translateZ(-1);
            //    // testCenter.translateY(5);



            //     console.log("c ", testCenter.position);
            //     console.log("l " , testLeft.position);
            //     console.log("r ",testRight.position);

            //     console.log(mesh.position);

            scene.add(mesh);

        }




        initTable();
        initCards();
        initPlayers(3);
        dealCards(deck, players);
        console.log(players);



        //console.log(deck);


        function dealCards(deck, players) {
            shuffleArray(deck);
            for (let i = 0; i < deck.length; i++) {
                if (i <= 17) {
                    players[0].playerDeck.push(deck[i]);
                }
                else if (17 < i && i <= 34) {
                    players[1].playerDeck.push(deck[i]);
                }
                else if (i > 34) {
                    players[2].playerDeck.push(deck[i]);
                }
            }

            rotateCards(players[0]);
            rotateCards(players[2]);
            console.log("player id to rotate", players[0].player);
            console.log("player id to rotate", players[2].player);
            placeCards(players);
        }



        function placeCards(players) {
            let playerX;
            let playerY;
            let playerZ;
            for (let i = 0; i < players.length; i++) {
                let height = .1;
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    height += .013;
                    playerX = players[i].playerPos.x;
                    playerY = players[i].playerPos.y;
                    playerZ = players[i].playerPos.z;
                    //  console.log(players[i].playerDeck[x]);
                    players[i].playerDeck[x].mesh.position.set(playerX, playerY, height);
                    // players[i].playerPos = new THREE.Vector3(playerX, playerY, lastHeight+.1);
                }
            }

        }


        function rotateCards(player) {
            for (let i = 0; i < player.playerDeck.length; i++) {
                player.playerDeck[i].mesh.rotation.y = Math.PI / 2;
            }
        }

        function rotateForCenter(player) {
            for (let i = 0; i < player.playerDeck.length; i++) {
                player.playerDeck[i].mesh.rotation.y = Math.PI;
            }
        }



        function animate() {
            updateSize();

            if (toggleUp == true) {
                console.log("aqui");
                moveCardUp();
            }
            if (toggleRotate == true) {
                console.log("HERE");
                rotate();
            }
            if (toggleMoveForward == true) {
                console.log("move forward");
                moveForward();
            }
            if (toggleDown == true) {
                console.log("move down");
                moveDown();
            }


            // plane.rotateX(.01);
            // plane.rotateY(.01);
            //   cube.rotateX(.01);
            //   cube.rotateY(.01);
            //    console.log(deck[0]);
            // for(let i = 0; i < players.length; i++){
            //     players[i].playerDeck[0].mesh.rotateX(.01);
            // }
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }


        //in: array [1,2,3] 
        //out: max
        function findWinOrWar(cardsInPlay) {
            let wars = -10;
            let max = 0;
            for (let y = 0; y < cardsInPlay.length; y++) {
                console.log("war: ", wars);
                console.log("max: ", max);
                console.log("card ", cardsInPlay[y].cardValue);
                //console.log("check ", cardsInPlay[y]);
                if (cardsInPlay[y].cardValue == max) {
                    console.log("equal");
                    wars = max;
                }
                if (cardsInPlay[y].cardValue > max) {
                    console.log("greater");
                    // console.log("greater");
                    max = cardsInPlay[y].cardValue;
                }
                // console.log("missed both");
            }
            // console.log("m check ", max);
            // console.log("w check ", war);
            if (max == wars) {
                console.log("CALL COMPARE AGAIN");
                max = -1;
                //console.log("war with ", war);
            }
            console.log("max is ", max);
            return max;
        }


        //in: array of players [0.1.2]
        //out: num players left
        function checkPlayers(players) {
            let index = -1;

            for (let i = 0; i < players.length; i++) {
                // console.log(i, " player deck ", players[i].playerDeck.length);
                if (players[i].playerDeck.length == 0) {
                    // console.log("remove player");
                    index = i;
                    // players = players.splice(i, 1);
                    // console.log("remaining players ", players);
                    // console.log(players.length, " players left");
                }
            }
            if (index > -1) {
                console.log("remove player ", players);
                players.splice(index, 1);
                console.log("remaining players ", players);
                console.log(players.length, " players left");
            }

            if (players.length == 1) {
                console.log("WINNER WINNER CHICKEN DINNER");
                for (let i = 0; i < checkPlayerDecks.length; i++) {
                    console.log("deck at the end ", checkPlayerDecks[i].playerDeck);
                }
                gameOver = true;
            }

            return players.length;


        }


        function tryMoveVertical(card, way) {
            if (way = 1) {
                card.mesh.translateY(.5);
            }
            else if (way = -1) {
                card.mesh.translateY(-.5);
            }
        }

        function tryFlip(card) {
            card.mesh.rotateX(3.15);
        }

        function tryMoveForward(card) {
            card.mesh.translateZ(.5);
        }


        function delay(milliseconds) {
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        }

        async  function tryLoop(id, card) {
            let i = 0;
            while (i < 20) {
                await delay(100);
                card.mesh.translateY(.01);
                i++;
            }
            trySpin(id, card);
        }

        async  function trySpin(id, card) {
            let i = 0;
            while (i < 30) {
                await delay(100);
                if (id == 1){
                    card.mesh.rotateX(-.5);
                }
                else{
                    card.mesh.rotateZ(-.05);
 
                }
               
                i++;
            }
        }

        //in: players array
        //out: an array of playing cards [1.2.3]
        function getCardsInPlay(players) {
            let cardsInPlay = [];
            for (let i = 0; i < players.length; i++) {
                cardsInPlay.push(players[i].currentCards[0]);
                console.log("player current card ", players[i].currentCards[0]);
                // tryMoveVertical(players[i].currentCards[0], -1);
                // tryFlip(players[i].currentCards[0]);
                //tryMoveForward(players[i].currentCards[0]);
                tryLoop(players[i].player, players[i].currentCards[0]);

                
            }
            //toggleMovement();

            return cardsInPlay;
        }

        //in player
        //out nothing
        function moveOneCard(players) {
            for (let i = 0; i < players.length; i++) {
                let topCard = players[i].playerDeck.pop();
                players[i].currentCards.unshift(topCard);
            }
        }

        //in: players
        //out: none
        function distributeWinnings(state, players) {
            console.log("state aka max", state);
            let spoils = [];
            let winner;
            let losers = [];
            console.log("p len ", players.length);
            for (let i = 0; i < players.length; i++) {
                let card = players[i].currentCards[0];
                console.log("card in distribute ", card);
                if (card.cardValue == state) {
                    winner = players[i];
                }
                else {
                    losers.push(i);
                }
                console.log("player cards ", players[i].currentCards);
                spoils = spoils.concat(players[i].currentCards);
                players[i].currentCards = [];
            }

            console.log("spoils of war ", spoils);
            console.log("winner ", winner);
            for (let i = 0; i < spoils.length; i++) {
                winner.playerDeck.unshift(spoils[i]);
            }
        }





        function makeMove(players, isThisWar) {
            let check = checkPlayers(players);

            console.log('console', players[1].playerDeck[0]);
            if (check > 1) {
                if (isThisWar == false) {
                    moveOneCard(players);
                }
                else {
                    moveOneCard(players);
                    moveOneCard(players);
                }

                let cards = getCardsInPlay(players);
                let state = findWinOrWar(cards);
                if (state == -1) {
                    console.log("War has begun");
                    makeMove(players, true);
                }
                else {
                    console.log('card', players[i].playerDeck[0].mesh);
                    distributeWinnings(state, players);

                    // placeCards(players);
                    for (let i = 0; i < players.length; i++) {
                        if (players[i].player == 0 || players[i].player == 2) {
                            console.log(" player id ", players[i].player);
                            // rotateCards(players[i]);
                        }
                        else if (players[i].player == 1) {
                            // rotateForCenter(players[i]);
                        }
                        console.log(i, " player deck length ", players[i].playerDeck.length);
                    }
                }
            }
            else {
                console.log("one player remains");
            }
        }























        //startwar: false=regular, true=war regular: put on card in current, war = put 2 cards in current
        function retryCompare(players, startWar) {

            let index = -1;

            for (let i = 0; i < players.length; i++) {
                // console.log(i, " player deck ", players[i].playerDeck.length);
                if (players[i].playerDeck.length == 0) {
                    // console.log("remove player");
                    index = i;
                    // players = players.splice(i, 1);
                    // console.log("remaining players ", players);
                    // console.log(players.length, " players left");
                }
            }
            if (index > -1) {
                console.log("remove player ", players);
                players.splice(index, 1);
                console.log("remaining players ", players);
                console.log(players.length, " players left");
            }

            if (players.length == 1) {
                console.log("WINNER WINNER CHICKEN DINNER");
            }



            let cardsInPlay = [];
            if (startWar == true) {
                for (let i = 0; i < players.length; i++) {
                    let topCard = players[i].playerDeck.pop();
                    //console.log(topCard);
                    players[i].currentCards.unshift(topCard);
                    cardsInPlay.push(topCard.cardValue);

                    //   console.log(i, " player current ", players[i].currentCards);
                }
                //   console.log("cards at play ", cardsInPlay);
            }
            else {
                for (let i = 0; i < players.length; i++) {
                    let topCard = players[i].playerDeck.pop();
                    // console.log(topCard);
                    players[i].currentCards.unshift(topCard);
                    topCard = players[i].playerDeck.pop();
                    //console.log(topCard);
                    players[i].currentCards.unshift(topCard);
                    cardsInPlay.push(topCard.cardValue);

                    // console.log(i, " player current ", players[i].currentCards);
                }
                //  console.log("cards at play ", cardsInPlay);

            }

            let war = 0;
            let max = 0;
            for (let y = 0; y < cardsInPlay.length; y++) {
                //console.log("check ", cardsInPlay[y]);
                if (cardsInPlay[y] == max) {
                    // console.log("equal");
                    war = max;
                }
                if (cardsInPlay[y] > max) {
                    // console.log("greater");
                    max = cardsInPlay[y];
                }


            }

            //  console.log("m check ", max);
            // console.log("w check ", war);
            if (max == war) {
                console.log("CALL COMPARE AGAIN");
                max = retryCompare(players, false);
                //console.log("war with ", war);

            }
            else {
                let spoils = [];
                let winner;
                let losers = [];
                for (let i = 0; i < players.length; i++) {
                    // console.log(i, " current cards ", players[i].currentCards);
                    let card = players[i].currentCards[0];
                    // console.log("player value ", card.cardValue);
                    // console.log("winning value ", max);
                    if (card.cardValue == max) {
                        winner = players[i];
                    }
                    else {
                        losers.push(i);
                    }

                    //console.log(i, " precheck current cards " , players[i].currentCards);
                    spoils = spoils.concat(players[i].currentCards);
                    // let card = players[i].currentCards.pop();
                    // console.log("card ", card);
                    //console.log("cardvalue ", card.cardValue);
                    //console.log("max ", max);
                    players[i].currentCards = [];
                    // spoils.unshift(card);
                    //console.log("player current ", players[i].currentCards);
                    // console.log(i, " player deck ", players[i].playerDeck.length);
                }
                //console.log("spoils ", spoils);
                //console.log("spoils of war ", spoils);
                //console.log("winner ", winner);
                for (let i = 0; i < spoils.length; i++) {
                    winner.playerDeck.unshift(spoils[i]);
                }
                // console.log("winner ", winner);
                //  console.log("winner deck ", winner.playerDeck.length);
                // for (let i = 0; i < losers.length; i++) {

                //    // console.log("loser deck ", players[losers[i]].playerDeck.length);
                // }



                // for (let i = 0; i < players.length; i++) {
                //   //  console.log(i, " check decks ", players[i].playerDeck.length);

                // }


                // console.log("winner with ", max);
            }
            return max;

        }

        //  retryCompare(players, false);








        function compareCards(players, firstWar) {
            let playedCards = [];
            for (let i = 0; i < players.length; i++) {
                console.log("player deck before ", players[i].playerDeck);
                console.log("current cards before ", players[i].currentCards);
                //  console.log(players[i].playerDeck[0].cardValue);
                if (firstWar == true) {
                    players[i].currentCards.unshift(players[i].playerDeck.pop());
                }
                else {
                    players[i].currentCards.unshift(players[i].playerDeck.pop());
                    players[i].currentCards.unshift(players[i].playerDeck.pop());
                }
                console.log("next card value ", players[i].currentCards[players[i].currentCards.length - 1].cardValue);
                playedCards.push(players[i].currentCards[players[i].currentCards.length - 1].cardValue);

                console.log("current cards after ", players[i].currentCards);
                console.log("player deck after ", players[i].playerDeck);


            }
            let war = -1;
            let max = -1;
            for (let i = 0; i < playedCards.length; i++) {
                if (playedCards[i] == max) {
                    //console.log("war triggered");
                    war = max;
                }
                if (playedCards[i] > max) {
                    max = playedCards[i];
                }
            }
            if (max == war) {
                enableWar = 1;
                console.log("into war == max");
                console.log(enableWar);
            }
            else {
                enableWar = 0;
            }
            console.log(playedCards);
            return max;
        }



        function moveCardUp() {
            console.log("HERE ", players);
            for (let i = 0; i <= 2; i++) {
                let length = players[i].currentCards.length;
                let mesh = players[i].currentCards[length - 1].mesh;
                if (mesh.position.z <= .5) {
                    console.log("HELLO");
                    mesh.position.z += .001;
                }
                else {
                    toggleUp = false;
                    toggleRotate = true;
                }
            }
        }



        function rotate() {
            for (let i = 0; i <= 2; i++) {
                let length = players[i].playerDeck.length;
                let mesh = players[i].playerDeck[length - 1].mesh;

                if (mesh.rotation.z >= -3) {
                    console.log(mesh.rotation.z);
                    mesh.rotateZ(.01);
                }
                else {
                    console.log("hello");
                    toggleRotate = false;
                    toggleMoveForward = true;
                }
            }
        }

        function moveForward() {
            let left, mid, right = true;
            for (let i = 0; i <= 2; i++) {
                let length = players[i].currentCards.length;
                let mesh = players[i].currentCards[0].mesh;


                if (i == 0) {
                    if (mesh.position.x <= -.75) {
                        console.log('mesh Y', mesh.position.x);
                        mesh.translateZ(.001);
                    }
                    else {
                        console.log("SHOULD TOGGLE FALSE");
                        left = false;
                    }
                }
                else if (i == 1) {
                    if (mesh.position.y <= -.75) {
                        console.log(mesh.position.z);
                        mesh.translateZ(-.001);
                    }
                    else {
                        console.log("toggle false");
                        mid = false;

                    }
                }
                else {
                    if (mesh.position.x >= .75) {
                        console.log('mesh Y', mesh.position.x);
                        mesh.translateZ(-.001);
                    }
                    else {
                        console.log("toggle false");
                        right = false;
                    }

                }
                if (left == false && mid == false && right == false) {
                    toggleMoveForward = false;
                    toggleDown = true;
                }
            }
        }

        function moveDown() {
            for (let i = 0; i <= 2; i++) {
                let length = players[i].currentCards.length;
                let mesh = players[i].currentCards[0].mesh;
                if (mesh.position.z >= .1) {
                    console.log("HELLO");
                    mesh.position.z += -.001;
                }
                else {
                    //   toggleUp = false;
                    toggleDown = false;
                    console.log("DONE");
                }

            }

        }



        function toggleMovement() {
            toggleUp = true;
        }





        function keyHandler(e) {
            switch (e.keyCode) {
                case 87: //w
                    bulbLight.translateY(.1);
                    break;
                case 83: //s
                    bulbLight.translateY(-.1);
                    break;
                case 68: //d
                    bulbLight.translateX(.1);
                    break;
                case 65: //a
                    bulbLight.translateX(-.1);
                    break;
                case 76: //L
                    ambientLightOn = !ambientLightOn;
                    if (ambientLightOn == true) {
                        light.visible = true;
                    }
                    else {
                        light.visible = false;
                    }
                    break;
                case 80: //P
                placeCards(players);
                    pointLightOn = !pointLightOn;
                    if (pointLightOn == true) {
                        bulbLight.visible = true;
                        bulbLight.position.set(0, -.79, 2);
                    }
                    else {
                        bulbLight.visible = false;
                    }
                    break;
                case 78:
                    if (gameOver == false) {
                        //retryCompare(players, true);
                        // for (let i = 0; i < 3; i++) {
                        //     let length = players[i].playerDeck.length;
                        //     moveCardUp(players[i].playerDeck[length - 1].mesh);
                        // }
                        //  toggleMovement();
                        makeMove(players, false);
                    }


                // if (enableWar == true) {
                //     retryCompare(players, true);
                // }
                // else {
                //     retryCompare(players, false);
                // }
                //         let winner = compareCards(players, true);
                //         console.log("enable war ", enableWar);
                //         if (enableWar == 1) {
                //             console.log("War");
                //             for (let i = 0; i < players.length; i++) {
                //                 players[i].currentCards = [];
                //             }
                //             let win = compareCards(players, false);
                //             //every player puts down 1 card upside down, 1 card right side up on top, compare again
                //         }

                //         console.log("someone wins ", winner);
                //         let allCards = [];
                //         for (let i = 0; i < players.length; i++) {
                //             allCards.unshift(players[i].currentCards);
                //         }
                //         console.log("cards after match ", allCards);
                //         for (let i = 0; i < players.length; i++) {
                //             console.log(winner);
                //             console.log(players[i].currentCards[0].cardValue);
                //             if (players[i].currentCards[0].cardValue == winner){
                //                 for(let x = 0; x < players[i].currentCards.length; x++){
                //                     players[i].playerDeck.unshift(players[i].currentCards[x]);
                //                 }
                //                 console.log("final player deck ", players[i].playerDeck);
                //             }
                //             players[i].currentCards = [];
                //         }
                //     //all cards go to player with the index of the max value

            }
        }


        document.addEventListener("keydown", keyHandler, false);



        animate();



        renderer.render(scene, camera);
    </script>
</body>

</html>