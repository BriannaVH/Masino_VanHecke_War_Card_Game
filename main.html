<html>

<head>
    <title>Three.js BuffedGeometry Example</title>
</head>

<body>

    <canvas id="myCanvas" width="1650" height="700"></canvas>


    <script type="module">

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";

        var scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let deck = [];
        let leftMid = new THREE.Vector3(-1.15, .075, 0);
        let rightMid = new THREE.Vector3(1.15, .075, 0);
        let centerMid = new THREE.Vector3(-.25, .075, 1.3);
        let positions = [leftMid, centerMid, rightMid];
        var enableWar = 0;
        var gameOver = false;
        let shadowCamera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        let toggleUp, toggleRotate, toggleMoveForward, toggleDown = false;






        //left player 0, middle player 1. right player 2, we are player 1 in the middle

        const shuffleArray = deck => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = deck[i];
                deck[i] = deck[j];
                deck[j] = temp;
            }
        }


        let woodTexture = 'misc_textures/table.jpg';

        let backOfCard = 'misc_textures/card_back.png';

        let clubs = ['card_Textures/ace_of_clubs.png', 'card_Textures/2_of_clubs.png', 'card_Textures/3_of_clubs.png', 'card_Textures/4_of_clubs.png', 'card_Textures/5_of_clubs.png',
            'card_Textures/6_of_clubs.png', 'card_Textures/7_of_clubs.png', 'card_Textures/8_of_clubs.png', 'card_Textures/9_of_clubs.png',
            'card_Textures/10_of_clubs.png', 'card_Textures/jack_of_clubs2.png', 'card_Textures/queen_of_clubs2.png',
            'card_Textures/king_of_clubs2.png'];

        let hearts = ['card_Textures/ace_of_hearts.png', 'card_Textures/2_of_hearts.png', 'card_Textures/3_of_hearts.png', 'card_Textures/4_of_hearts.png', 'card_Textures/5_of_hearts.png',
            'card_Textures/6_of_hearts.png', 'card_Textures/7_of_hearts.png', 'card_Textures/8_of_hearts.png', 'card_Textures/9_of_hearts.png',
            'card_Textures/10_of_hearts.png', 'card_Textures/jack_of_hearts2.png', 'card_Textures/queen_of_hearts2.png', 'card_Textures/king_of_hearts2.png'];


        let diamonds = ['card_Textures/ace_of_diamonds.png', 'card_Textures/2_of_diamonds.png', 'card_Textures/3_of_diamonds.png', 'card_Textures/4_of_diamonds.png',
            'card_Textures/5_of_diamonds.png', 'card_Textures/6_of_diamonds.png', 'card_Textures/7_of_diamonds.png', 'card_Textures/8_of_diamonds.png', 'card_Textures/9_of_diamonds.png',
            'card_Textures/10_of_diamonds.png', 'card_Textures/jack_of_diamonds2.png', 'card_Textures/queen_of_diamonds2.png', 'card_Textures/king_of_diamonds2.png'];


        let spades = ['card_Textures/ace_of_spades.png', 'card_Textures/2_of_spades.png', 'card_Textures/3_of_spades.png', 'card_Textures/4_of_spades.png',
            'card_Textures/5_of_spades.png', 'card_Textures/6_of_spades.png', 'card_Textures/7_of_spades.png', 'card_Textures/8_of_spades.png',
            'card_Textures/9_of_spades.png', 'card_Textures/10_of_spades.png', 'card_Textures/jack_of_spades2.png', 'card_Textures/queen_of_spades2.png', 'card_Textures/king_of_spades2.png'];

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.x = 0;  // Try moving this around!
        camera.position.y = 2.5;
        camera.position.z = 4;  // Try moving this around!
        // camera.position.x = 0;  // There are our camera positions
        // camera.position.y = -4;
        // camera.position.z = 2;  // Try moving this around!
        var focal = new THREE.Vector3(0.0, 0.0, 0.0);
        camera.lookAt(focal);
        scene.add(camera);







        // #FFC0CB
        //0x0000ff
        const light = new THREE.AmbientLight(0xFF66CC, 1); // soft white light
        scene.add(light);


        // const plight = new THREE.PointLight(0xa0adaf, 100, 100);
        // plight.position.set(0, 0, 0);
        // scene.add(plight);


        // const sphereSize = 1;
        // const pointLightHelper = new THREE.PointLightHelper(plight, sphereSize);
        // scene.add(pointLightHelper);

        // plight.add(mesh);

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //Sets the size of the renderer to the entirety of the


        console.log("camera position", camera.position);

        const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
        // bulbGeometry.position.set(3,0,0);
        let bulbLight = new THREE.PointLight(0xffee88, 1.5, 100, 2);

        let bulbMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: 1,
            color: 0x000000
        });
        bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
        bulbLight.position.set(0, .79, -2);
        bulbLight.castShadow = true;
        scene.add(bulbLight);

        shadowCamera.position.x = bulbLight.position.x;
        shadowCamera.position.y = bulbLight.position.y;
        shadowCamera.position.z = bulbLight.position.z;
        console.log(shadowCamera.position);


        const loader = new THREE.TextureLoader();

        const geometry = new THREE.BoxGeometry(.2, .01, .4);

        let i = 0;

        const materials = [

            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
            new THREE.MeshBasicMaterial({ map: loader.load(diamonds[2]) }), //this is the front
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }), //this is the back of the card
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
            new THREE.MeshBasicMaterial({ map: loader.load(backOfCard) }),
        ];

        let planeGeometry = new THREE.PlaneGeometry(100, 100);
        let planeMaterial = new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky2.jpg'), side: THREE.DoubleSide });
        let planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
        //planeMesh.rotateX(1);
        scene.add(planeMesh);
        planeMesh.position.set(0, -35, -40);






        const testCard = new THREE.Mesh(geometry, materials);
        //scene.add(testCard);
        //testCard.rotateX(1);


        let players = [];
        let checkPlayerDecks = [];

        function Player(playerID, playerPosition) {
            this.cardsLeft = true;
            this.player = playerID;
            this.playerDeck = [];
            this.playing = true;
            this.currentCards = [];
            this.playerPos = playerPosition;
        }

        function Card(value, suit) {
            //Suit:
            //1 -- Spade
            //2 -- Hearts
            //3 -- Clubs
            //4 -- Diamonds
            this.cardValue = value;
            this.cardSuit = suit;

            this.geometry = new THREE.BoxGeometry(.2, .001, .4);
            this.material = makeMaterial(this.cardValue, this.cardSuit);

            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.rotation.x = 0;
            this.mesh.translateY(5);

            console.log(this.mesh.rotation.y, 'ROTATION Y ORIGIN');

            scene.add(this.mesh);
        }

        function makeMaterial(value, suit) {
            const materials = [

                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ map: loader.load(backOfCard) }), //this is the front
                new THREE.MeshPhongMaterial({ map: loader.load(backOfCard) }), //this is the back of the card
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
            ];

            let index = value - 1;
            let string;
            let material;

            if (suit == 1) { //Spade
                string = spades[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 2) { //Hearts
                string = hearts[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 3) { //Clubs
                string = clubs[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 4) { //Diamonds
                string = diamonds[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            //console.log(material);
            return materials;
        }

        function initCards() {
            let card;

            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 1);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 2);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 3);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 4);
                deck.push(card);
            }

            // console.log(deck);
            //testing
            // for (let i = 0; i < deck.length; i++) {
            //    // console.log("i", i);
            //     //console.log(deck[i].mesh);
            //     deck[i].mesh.rotateX(Math.random());
            //     deck[i].mesh.rotateY(Math.random());
            //     deck[i].mesh.rotateZ(Math.random());
            //     deck[i].mesh.translateX(Math.random());
            //     deck[i].mesh.translateY(Math.random());
            // }
        }




        function initPlayers(number) {
            let player;
            for (let i = 0; i < number; i++) {
                player = new Player(i, positions[i]);
                players.push(player);
            }
            checkPlayerDecks = players;
        }

        function testShape() {
            let geom = new THREE.BoxGeometry(.25, .25, .25);
            let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            let mesh = new THREE.Mesh(geom, material);
            mesh.position.set(0, 0, 0);
            scene.add(mesh);
            return mesh;
        }

        //  testShape();


        function initTable() {
            let string1 = 'floor/floor2.png';
            let geometry = new THREE.BoxGeometry(3, .15, 3);
            let material = new THREE.MeshPhongMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(woodTexture),

            });
            let mesh = new THREE.Mesh(geometry, material);

            console.log(mesh, 'mesh');
            scene.add(mesh);

        }






        initTable();
        initCards();
        initPlayers(3);
        dealCards(deck, players);
        console.log(players);



        //console.log(deck);


        function dealCards(deck, players) {
            shuffleArray(deck);
            for (let i = 0; i < deck.length; i++) {
                if (i <= 17) {
                    players[0].playerDeck.push(deck[i]);
                }
                else if (17 < i && i <= 34) {
                    players[1].playerDeck.push(deck[i]);
                }
                else if (i > 34) {
                    players[2].playerDeck.push(deck[i]);
                }
            }

            setOriginPosition(players);


            // rotateCards(players[2]);
            console.log("player id to rotate", players[0].player);
            console.log("player id to rotate", players[2].player);
            console.log("card placement, ", players[1].playerDeck[0].mesh.position);
            placeCards(players);
        }



        function placeCards(players) {
            let playerX;
            let playerY;
            let playerZ;
            for (let i = 0; i < players.length; i++) {
                let height = .1;
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    height += .013;
                    playerX = players[i].playerPos.x;
                    playerY = players[i].playerPos.y;
                    playerZ = players[i].playerPos.z;
                    //  console.log(players[i].playerDeck[x]);
                    players[i].playerDeck[x].mesh.position.set(playerX, playerY + height, playerZ);
                    // players[i].playerPos = new THREE.Vector3(playerX, playerY, lastHeight+.1);
                }
            }

        }


        function setOriginPosition(players) {
            for (let i = 0; i < players.length; i++) {
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    players[i].playerDeck[x].mesh.rotation.x = 0;
                    if (players[i].player == 0 || players[i].player == 2) {
                        players[i].playerDeck[x].mesh.rotation.y = -1.55;
                    }
                    else if (players[i].player == 1) {
                        players[i].playerDeck[x].mesh.rotation.y = 0;

                        players[i].playerDeck[x].mesh.rotation.x = 0;

                    }

                }

            }


        }

        // function rotateCardsPlacement(players){

        //     for (let i = 0; i < players.length; i++){


        //     }


        // }

        function rotateForCenter(player) {
            for (let i = 0; i < player.playerDeck.length; i++) {
                players[i].playerDeck[x].mesh.rotateY(1);
            }
        }



        function animate() {
            updateSize();

            if (toggleUp == true) {
                console.log("aqui");
                moveCardUp();
            }
            if (toggleRotate == true) {
                console.log("HERE");
                rotate();
            }
            if (toggleMoveForward == true) {
                console.log("move forward");
                moveForward();
            }
            if (toggleDown == true) {
                console.log("move down");
                moveDown();
            }


            // plane.rotateX(.01);
            // plane.rotateY(.01);
            //   cube.rotateX(.01);
            //   cube.rotateY(.01);
            //    console.log(deck[0]);
            // for(let i = 0; i < players.length; i++){
            //     players[i].playerDeck[0].mesh.rotateX(.01);
            // }
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }


        //in: array [1,2,3] 
        //out: max
        function findWinOrWar(cardsInPlay) {
            let wars = -10;
            let max = 0;
            for (let y = 0; y < cardsInPlay.length; y++) {
                console.log("war: ", wars);
                console.log("max: ", max);
                console.log("card ", cardsInPlay[y].cardValue);
                //console.log("check ", cardsInPlay[y]);
                if (cardsInPlay[y].cardValue == max) {
                    console.log("equal");
                    wars = max;
                }
                if (cardsInPlay[y].cardValue > max) {
                    console.log("greater");
                    // console.log("greater");
                    max = cardsInPlay[y].cardValue;
                }
                // console.log("missed both");
            }
            // console.log("m check ", max);
            // console.log("w check ", war);
            if (max == wars) {
                console.log("CALL COMPARE AGAIN");
                max = -1;
                //console.log("war with ", war);
            }
            console.log("max is ", max);
            return max;
        }


        //in: array of players [0.1.2]
        //out: num players left
        function checkPlayers(players) {
            let count = 0;

            for (let i = 0; i < players.length; i++) {
                // console.log(i, " player deck ", players[i].playerDeck.length);
                if (players[i].playerDeck.length == 0) {
                    players[i].playing = false;
                    if (players[i].playing == false) {
                        count++;
                    }
                }
            }

            if (count == 2) {
                console.log("WINNER WINNER CHICKEN DINNER");
                for (let i = 0; i < players.length; i++) {
                    console.log("deck at the end ", players[i].playerDeck);
                }
                gameOver = true;
                return false;
            }
            else {
                return true;
            }

        }


        function tryMoveVertical(card, way) {
            if (way = 1) {
                card.mesh.translateY(.5);
            }
            else if (way = -1) {
                card.mesh.translateY(-.5);
            }
        }

        function tryFlip(card) {
            card.mesh.rotateY(3.15);
        }

        function tryMoveForward(card) {
            card.mesh.translateZ(.5);
        }


        function delay(milliseconds) {
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        }

        async function tryLoop(id, card) {
            let i = 0;
            while (i < 20) {
                await delay(100);
                card.mesh.translateY(.01);
                i++;
            }
            trySpin(id, card);
        }

        async function trySpin(id, card) {
            let i = 0;
            while (i < 30) {
                await delay(100);
                if (id == 1) {
                    card.mesh.rotateX(-.5);
                }
                else {
                    card.mesh.rotateZ(-.05);

                }

                i++;
            }
        }

        //in: players array
        //out: an array of playing cards [1.2.3]
        function getCardsInPlay(players) {
            let cardsInPlay = [];
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    cardsInPlay.push(players[i].currentCards[0]);
                    console.log("player current card ", players[i].currentCards[0]);
                    // tryMoveVertical(players[i].currentCards[0], -1);
                    // tryFlip(players[i].currentCards[0]);
                    //tryMoveForward(players[i].currentCards[0]);
                    //tryLoop(players[i].player, players[i].currentCards[0]);
                }
            }
            //toggleMovement();

            return cardsInPlay;
        }

        //in player
        //out nothing
        function moveOneCard(players) {
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    if (players[i].playerDeck.length == 0) {
                        players[i].playing = false;
                    }
                    else {
                        let topCard = players[i].playerDeck.pop();
                        players[i].currentCards.unshift(topCard);
                    }

                }
            }
        }

        //in: players
        //out: none
        function distributeWinnings(winner, players) {
            let spoils = [];
            console.log("p len ", players.length);
            for (let i = 0; i < players.length; i++) {
                spoils = spoils.concat(players[i].currentCards);
                players[i].currentCards = [];

            }
            console.log("spoils of war ", spoils);
            console.log("winner ", winner);
            for (let i = 0; i < spoils.length; i++) {
                winner.playerDeck.unshift(spoils[i]);
            }
        }





        function makeMove(players, isThisWar) {
            let check = checkPlayers(players);
            if (check == true) {
                if (isThisWar == false) {
                    moveOneCard(players);
                }
                else {
                    moveOneCard(players);
                    moveOneCard(players);
                }

                let cards = getCardsInPlay(players);
                let state = findWinOrWar(cards);
                if (state == -1) {
                    console.log("War has begun");
                    makeMove(players, true);
                }
                else {
                    let winner;
                    for (let i = 0; i < players.length; i++) {
                        if (players[i].playing == true) {
                            let card = players[i].currentCards[0];
                            console.log("card in distribute ", card);
                            if (card.cardValue == state) {
                                winner = players[i];
                            }
                        }
                    }
                    distributeWinnings(winner, players);
                    placeCards(players);

                    for (let i = 0; i < players.length; i++) {
                        if (players[i].playing == true) {
                            setOriginPosition(players);
                            console.log(i, " player deck length ", players[i].playerDeck.length);
                        }

                    }
                }
            }
            else {
                let winner;
                for (let i = 0; i < players.length; i++) {
                    if (players[i].player == true) {
                        winner = players[i].player;
                    }
                }
                distributeWinnings(winner, players);
                placeCards(players);
                console.log("one player remains");
            }
        }



































        function moveCardUp() {
            console.log("HERE ", players);
            for (let i = 0; i <= 2; i++) {
                let length = players[i].currentCards.length;
                let mesh = players[i].currentCards[length - 1].mesh;
                if (mesh.position.z <= .5) {
                    console.log("HELLO");
                    mesh.position.z += .001;
                }
                else {
                    toggleUp = false;
                    toggleRotate = true;
                }
            }
        }



        function rotate() {
            for (let i = 0; i <= 2; i++) {
                let length = players[i].playerDeck.length;
                let mesh = players[i].playerDeck[length - 1].mesh;

                if (mesh.rotation.z >= -3) {
                    console.log(mesh.rotation.z);
                    mesh.rotateZ(.01);
                }
                else {
                    console.log("hello");
                    toggleRotate = false;
                    toggleMoveForward = true;
                }
            }
        }

        function moveForward() {
            let left, mid, right = true;
            for (let i = 0; i <= 2; i++) {
                let length = players[i].currentCards.length;
                let mesh = players[i].currentCards[0].mesh;


                if (i == 0) {
                    if (mesh.position.x <= -.75) {
                        console.log('mesh Y', mesh.position.x);
                        mesh.translateZ(.001);
                    }
                    else {
                        console.log("SHOULD TOGGLE FALSE");
                        left = false;
                    }
                }
                else if (i == 1) {
                    if (mesh.position.y <= -.75) {
                        console.log(mesh.position.z);
                        mesh.translateZ(-.001);
                    }
                    else {
                        console.log("toggle false");
                        mid = false;

                    }
                }
                else {
                    if (mesh.position.x >= .75) {
                        console.log('mesh Y', mesh.position.x);
                        mesh.translateZ(-.001);
                    }
                    else {
                        console.log("toggle false");
                        right = false;
                    }

                }
                if (left == false && mid == false && right == false) {
                    toggleMoveForward = false;
                    toggleDown = true;
                }
            }
        }

        function moveDown() {
            for (let i = 0; i <= 2; i++) {
                let length = players[i].currentCards.length;
                let mesh = players[i].currentCards[0].mesh;
                if (mesh.position.z >= .1) {
                    console.log("HELLO");
                    mesh.position.z += -.001;
                }
                else {
                    //   toggleUp = false;
                    toggleDown = false;
                    console.log("DONE");
                }

            }

        }



        function toggleMovement() {
            toggleUp = true;
        }





        function keyHandler(e) {
            switch (e.keyCode) {
                case 87: //w
                    bulbLight.translateZ(-.1);
                    break;
                case 83: //s
                    bulbLight.translateZ(.1);
                    break;
                case 68: //d
                    bulbLight.translateX(.1);
                    break;
                case 65: //a
                    bulbLight.translateX(-.1);
                    break;
                case 76: //L
                    light.visible = !light.visible;
                    break;
                case 80: //P
                    //placeCards(players);
                    bulbLight.visible = !bulbLight.visible;
                    bulbLight.position.set(0, .79, -2);
                    break;
                case 78:
                    if (gameOver == false) {

                        //  toggleMovement();
                        makeMove(players, false);
                    }




            }
        }


        document.addEventListener("keydown", keyHandler, false);



        animate();



        renderer.render(scene, camera);
    </script>
</body>

</html>