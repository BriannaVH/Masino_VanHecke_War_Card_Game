<html>

<head>
    <title>Three.js BuffedGeometry Example</title>
</head>

<body>

    <canvas id="myCanvas" width="1650" height="700"></canvas>


    <script type="module">

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";

        var scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let deck = [];
        let leftMid = new THREE.Vector3(-1.15, 0, 0);
        let rightMid = new THREE.Vector3(1.15, 0, 0);
        let centerMid = new THREE.Vector3(0, 0, 0);
        let positions = [leftMid, centerMid, rightMid];
        var enableWar = 0;
        var gameOver = false;
        let shadowCamera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        let players = [];
        let checkPlayerDecks = [];


        let woodTexture = 'misc_textures/table.jpg';
        let backOfCard = 'misc_textures/card_back.png';

        let clubs = ['card_Textures/ace_of_clubs.png', 'card_Textures/2_of_clubs.png', 'card_Textures/3_of_clubs.png', 'card_Textures/4_of_clubs.png', 'card_Textures/5_of_clubs.png',
            'card_Textures/6_of_clubs.png', 'card_Textures/7_of_clubs.png', 'card_Textures/8_of_clubs.png', 'card_Textures/9_of_clubs.png',
            'card_Textures/10_of_clubs.png', 'card_Textures/jack_of_clubs2.png', 'card_Textures/queen_of_clubs2.png',
            'card_Textures/king_of_clubs2.png'];
        let hearts = ['card_Textures/ace_of_hearts.png', 'card_Textures/2_of_hearts.png', 'card_Textures/3_of_hearts.png', 'card_Textures/4_of_hearts.png', 'card_Textures/5_of_hearts.png',
            'card_Textures/6_of_hearts.png', 'card_Textures/7_of_hearts.png', 'card_Textures/8_of_hearts.png', 'card_Textures/9_of_hearts.png',
            'card_Textures/10_of_hearts.png', 'card_Textures/jack_of_hearts2.png', 'card_Textures/queen_of_hearts2.png', 'card_Textures/king_of_hearts2.png'];
        let diamonds = ['card_Textures/ace_of_diamonds.png', 'card_Textures/2_of_diamonds.png', 'card_Textures/3_of_diamonds.png', 'card_Textures/4_of_diamonds.png',
            'card_Textures/5_of_diamonds.png', 'card_Textures/6_of_diamonds.png', 'card_Textures/7_of_diamonds.png', 'card_Textures/8_of_diamonds.png', 'card_Textures/9_of_diamonds.png',
            'card_Textures/10_of_diamonds.png', 'card_Textures/jack_of_diamonds2.png', 'card_Textures/queen_of_diamonds2.png', 'card_Textures/king_of_diamonds2.png'];
        let spades = ['card_Textures/ace_of_spades.png', 'card_Textures/2_of_spades.png', 'card_Textures/3_of_spades.png', 'card_Textures/4_of_spades.png',
            'card_Textures/5_of_spades.png', 'card_Textures/6_of_spades.png', 'card_Textures/7_of_spades.png', 'card_Textures/8_of_spades.png',
            'card_Textures/9_of_spades.png', 'card_Textures/10_of_spades.png', 'card_Textures/jack_of_spades2.png', 'card_Textures/queen_of_spades2.png', 'card_Textures/king_of_spades2.png'];

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.x = 0;  // Try moving this around!
        camera.position.y = 2.5;
        camera.position.z = 4;  // Try moving this around!

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //Sets the size of the renderer to the entirety of the
        var focal = new THREE.Vector3(0.0, 0.0, 0.0);
        camera.lookAt(focal);
        scene.add(camera);


        // #FFC0CB
        //0x0000ff
        const light = new THREE.AmbientLight(0xFF66CC, 1); // soft white light
        scene.add(light);

        console.log("camera position", camera.position);

        const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
        // bulbGeometry.position.set(3,0,0);
        let bulbLight = new THREE.PointLight(0xffee88, 1.5, 100, 2);

        let bulbMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: 1,
            color: 0x000000
        });
        bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
        bulbLight.position.set(0, .79, -2);
        bulbLight.castShadow = true;
        scene.add(bulbLight);

        shadowCamera.position.x = bulbLight.position.x;
        shadowCamera.position.y = bulbLight.position.y;
        shadowCamera.position.z = bulbLight.position.z;
        console.log(shadowCamera.position);


        const loader = new THREE.TextureLoader();
        const geometry = new THREE.BoxGeometry(.2, .01, .4);

        //let i = 0;

        //left player 0, middle player 1. right player 2, we are player 1 in the middle
        const shuffleArray = deck => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = deck[i];
                deck[i] = deck[j];
                deck[j] = temp;
            }
        }

        function Player(playerID, playerPosition) {
            this.cardsLeft = true;
            this.player = playerID;
            this.playerDeck = [];
            this.playing = true;
            this.currentCards = [];
            this.playerPos = playerPosition;
        }

        function Card(value, suit) {
            //Suit:
            //1 -- Spade
            //2 -- Hearts
            //3 -- Clubs
            //4 -- Diamonds
            this.cardValue = value;
            this.cardSuit = suit;

            this.geometry = new THREE.BoxGeometry(.3, .01, .6);
            this.material = makeMaterial(this.cardValue, this.cardSuit);

            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.rotation.x = 0;
            this.mesh.translateY(5);

            console.log(this.mesh.rotation.y, 'ROTATION Y ORIGIN');

            scene.add(this.mesh);
        }

        function makeMaterial(value, suit) {
            const materials = [

                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ map: loader.load(backOfCard) }), //this is the front
                new THREE.MeshPhongMaterial({ map: loader.load(backOfCard) }), //this is the back of the card
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
                new THREE.MeshPhongMaterial({ color: 0xffffff }),
            ];

            let index = value - 1;
            let string;
            let material;

            if (suit == 1) { //Spade
                string = spades[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 2) { //Hearts
                string = hearts[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 3) { //Clubs
                string = clubs[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 4) { //Diamonds
                string = diamonds[index];
                material = new THREE.MeshPhongMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            //console.log(material);
            return materials;
        }

        function initCards() {
            let card;

            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 1);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 2);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 3);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 4);
                deck.push(card);
            }
        }

        function initPlayers(number) {
            let player;
            for (let i = 0; i < number; i++) {
                player = new Player(i, positions[i]);
                players.push(player);
            }
            checkPlayerDecks = players;
        }

        function testShape() {
            let geom = new THREE.BoxGeometry(.25, .25, .25);
            let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            let mesh = new THREE.Mesh(geom, material);
            mesh.position.set(0, 0, 0);
            scene.add(mesh);
            return mesh;
        }

        //  testShape();


        function initTable() {
            let string1 = 'floor/floor2.png';
            let geometry = new THREE.BoxGeometry(3, .15, 3);
            let material = new THREE.MeshPhongMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(woodTexture),

            });
            let mesh = new THREE.Mesh(geometry, material);

            console.log(mesh, 'mesh');
            scene.add(mesh);
        }

        function initHorizon() {
            let planeGeometry = new THREE.PlaneGeometry(100, 100);
            let planeMaterial = new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky2.jpg'), side: THREE.DoubleSide });
            let planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            //planeMesh.rotateX(1);
            scene.add(planeMesh);
            planeMesh.position.set(0, -35, -40);
        }


        function dealCards(deck, players) {
            shuffleArray(deck);
            for (let i = 0; i < deck.length; i++) {
                if (i <= 17) {
                    players[0].playerDeck.push(deck[i]);
                }
                else if (17 < i && i <= 34) {
                    players[1].playerDeck.push(deck[i]);
                }
                else if (i > 34) {
                    players[2].playerDeck.push(deck[i]);
                }
            }

            setOriginPosition(players);

            // rotateCards(players[2]);
            console.log("player id to rotate", players[0].player);
            console.log("player id to rotate", players[2].player);
            console.log("card placement, ", players[1].playerDeck[0].mesh.position);
            placeCards(players);
        }


        function placeCards(players) {
            let playerX;
            let playerY;
            let playerZ;
            for (let i = 0; i < players.length; i++) {
                let height = .075;
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    height += .013;
                    playerX = players[i].playerPos.x;
                    playerY = players[i].playerPos.y;
                    playerZ = players[i].playerPos.z;
                    //  console.log(players[i].playerDeck[x]);
                    players[i].playerDeck[x].mesh.position.set(playerX, playerY + height, playerZ);
                    // players[i].playerPos = new THREE.Vector3(playerX, playerY, lastHeight+.1);
                }
            }

        }

        function setOriginPosition(players) {
            for (let i = 0; i < players.length; i++) {
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    players[i].playerDeck[x].mesh.rotation.x = 0;
                    players[i].playerDeck[x].mesh.rotation.y = 0;
                }
            }
        }

        function delay(milliseconds) {
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        }

        async function moveUp(id, card) {
            let i = 0;
            while (i < 20) {
                await delay(100);
                card.mesh.translateY(.01);
                i++;
            }
            flip(id, card);
        }

        async function flip(id, card) {
            let i = 0;
            while (i < 30) {
                await delay(100);
                if (id == 1) {
                    card.mesh.rotateZ(-.105);
                }
                else {
                    card.mesh.rotateZ(-.105);

                }
                i++;
            }
            moveForward(id, card);
        }

        async function moveForward(id, card) {

            while (card.mesh.position.z <= 1) {
                await delay(100);
                card.mesh.translateZ(.05);

            }
            moveDown(card, -1);
        }

        async function moveDown(card, way) {
            while (card.mesh.position.y >= .081) {
                await delay(100);
                if (way = 1) {
                    card.mesh.translateY(.01);
                }
                else if (way = -1) {
                    card.mesh.translateY(-.01);
                }
            }
        }


        //in: array of players [0.1.2]
        //out: num players left
        function checkPlayers(players) {
            let count = 0;

            for (let i = 0; i < players.length; i++) {
                // console.log(i, " player deck ", players[i].playerDeck.length);
                if (players[i].playerDeck.length == 0) {
                    players[i].playing = false;
                    if (players[i].playing == false) {
                        count++;
                    }
                }
            }

            if (count == 2) {
                console.log("WINNER WINNER CHICKEN DINNER");
                for (let i = 0; i < players.length; i++) {
                    console.log("deck at the end ", players[i].playerDeck);
                }
                gameOver = true;
                return false;
            }
            else {
                return true;
            }

        }

         //in player
        //out nothing
        function moveOneCard(players) {
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    if (players[i].playerDeck.length == 0) {
                        players[i].playing = false;
                    }
                    else {
                        let topCard = players[i].playerDeck.pop();
                        players[i].currentCards.unshift(topCard);
                    }

                }
            }
        }

        //in: players array
        //out: an array of playing cards [1.2.3]
        function getCardsInPlay(players) {
            let cardsInPlay = [];
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    cardsInPlay.push(players[i].currentCards[0]);
                    console.log("player current card ", players[i].currentCards[0]);
                    // tryMoveVertical(players[i].currentCards[0], -1);
                    // tryFlip(players[i].currentCards[0]);
                    //tryMoveForward(players[i].currentCards[0]);
                    moveUp(players[i].player, players[i].currentCards[0]);
                    //players[i].currentCards[0].mesh.translateY(.5);

                }
            }
            //toggleMovement();

            return cardsInPlay;
        }


        //in: array [1,2,3] 
        //out: max
        function findWinOrWar(cardsInPlay) {
            let wars = -10;
            let max = 0;
            for (let y = 0; y < cardsInPlay.length; y++) {
                console.log("war: ", wars);
                console.log("max: ", max);
                console.log("card ", cardsInPlay[y].cardValue);
                //console.log("check ", cardsInPlay[y]);
                if (cardsInPlay[y].cardValue == max) {
                    console.log("equal");
                    wars = max;
                }
                if (cardsInPlay[y].cardValue > max) {
                    console.log("greater");
                    // console.log("greater");
                    max = cardsInPlay[y].cardValue;
                }
                // console.log("missed both");
            }
            // console.log("m check ", max);
            // console.log("w check ", war);
            if (max == wars) {
                console.log("CALL COMPARE AGAIN");
                max = -1;
                //console.log("war with ", war);
            }
            console.log("max is ", max);
            return max;
        }


        //in: players
        //out: none
        function distributeWinnings(winner, players) {
            let spoils = [];
            console.log("p len ", players.length);
            for (let i = 0; i < players.length; i++) {
                spoils = spoils.concat(players[i].currentCards);
                players[i].currentCards = [];

            }
            console.log("spoils of war ", spoils);
            console.log("winner ", winner);
            for (let i = 0; i < spoils.length; i++) {
                winner.playerDeck.unshift(spoils[i]);
            }
        }


        function makeMove(players, isThisWar) {
            let check = checkPlayers(players);
            if (check == true) {
                if (isThisWar == false) {
                    moveOneCard(players);
                }
                else {
                    moveOneCard(players);
                    moveOneCard(players);
                }

                let cards = getCardsInPlay(players);
                let state = findWinOrWar(cards);
                if (state == -1) {
                    console.log("War has begun");
                    makeMove(players, true);
                }
                else {
                    let winner;
                    for (let i = 0; i < players.length; i++) {
                        if (players[i].playing == true) {
                            let card = players[i].currentCards[0];
                            console.log("card in distribute ", card);
                            if (card.cardValue == state) {
                                winner = players[i];
                            }
                        }
                    }
                    distributeWinnings(winner, players);
                    //placeCards(players);


                    for (let i = 0; i < players.length; i++) {
                        if (players[i].playing == true) {
                            //  setOriginPosition(players);
                            console.log(i, " player deck length ", players[i].playerDeck.length);
                        }

                    }
                }
            }
            else {
                let winner;
                for (let i = 0; i < players.length; i++) {
                    if (players[i].player == true) {
                        winner = players[i].player;
                    }
                }
                distributeWinnings(winner, players);
                placeCards(players);
                console.log("one player remains");
            }
        }


        function animate() {
            updateSize();


            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }


        function keyHandler(e) {
            switch (e.keyCode) {
                case 87: //w
                    bulbLight.translateZ(-.1);
                    break;
                case 83: //s
                    bulbLight.translateZ(.1);
                    break;
                case 68: //d
                    bulbLight.translateX(.1);
                    break;
                case 65: //a
                    bulbLight.translateX(-.1);
                    break;
                case 76: //L
                    light.visible = !light.visible;
                    break;
                case 80: //P
                    //placeCards(players);
                    bulbLight.visible = !bulbLight.visible;
                    bulbLight.position.set(0, .79, -2);
                    break;
                case 78:
                    if (gameOver == false) {

                        //  toggleMovement();
                        makeMove(players, false);
                    }
            }
        }


        document.addEventListener("keydown", keyHandler, false);


        initTable();
        initCards();
        initHorizon();
        initPlayers(3);
        dealCards(deck, players);
        console.log(players);

        animate();

        renderer.render(scene, camera);
    </script>
</body>

</html>