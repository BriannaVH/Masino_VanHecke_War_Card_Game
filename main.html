<html>

<head>
    <title>WAR Card Game</title>
</head>

<body>

    <canvas id="myCanvas" width="1650" height="700"></canvas>

    <script type="module">

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { RectAreaLight } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/src/lights/RectAreaLight.js";

        var scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let deck = [];
        let players = [];
        let tableMesh;
        let floorMesh;
        let leftMid = new THREE.Vector3(-1.15, 0, 0);
        let rightMid = new THREE.Vector3(1.15, 0, 0);
        let centerMid = new THREE.Vector3(0, 0, 0);
        let positions = [leftMid, centerMid, rightMid];
        let cardPlacement = .08;
        const width1 = 5;
        const height1 = 5;
        const intensity = 1;
        let movePermitted = true;
        var gameOver = false;
        let sky0 = false;
        const loader = new THREE.TextureLoader();

        let woodTexture = 'misc_textures/table.jpg';
        let backOfCard = 'misc_textures/card_back.png';

        let skies = [
            new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky0.png'), side: THREE.DoubleSide }),
            new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky2.jpg'), side: THREE.DoubleSide })
        ];


        let clubs = ['card_Textures/2_of_clubs.png', 'card_Textures/3_of_clubs.png', 'card_Textures/4_of_clubs.png', 'card_Textures/5_of_clubs.png',
            'card_Textures/6_of_clubs.png', 'card_Textures/7_of_clubs.png', 'card_Textures/8_of_clubs.png', 'card_Textures/9_of_clubs.png',
            'card_Textures/10_of_clubs.png', 'card_Textures/jack_of_clubs2.png', 'card_Textures/queen_of_clubs2.png',
            'card_Textures/king_of_clubs2.png', 'card_Textures/ace_of_clubs.png'];

        let hearts = ['card_Textures/2_of_hearts.png', 'card_Textures/3_of_hearts.png', 'card_Textures/4_of_hearts.png', 'card_Textures/5_of_hearts.png',
            'card_Textures/6_of_hearts.png', 'card_Textures/7_of_hearts.png', 'card_Textures/8_of_hearts.png', 'card_Textures/9_of_hearts.png',
            'card_Textures/10_of_hearts.png', 'card_Textures/jack_of_hearts2.png', 'card_Textures/queen_of_hearts2.png', 'card_Textures/king_of_hearts2.png',
            'card_Textures/ace_of_hearts.png'];

        let diamonds = ['card_Textures/2_of_diamonds.png', 'card_Textures/3_of_diamonds.png', 'card_Textures/4_of_diamonds.png',
            'card_Textures/5_of_diamonds.png', 'card_Textures/6_of_diamonds.png', 'card_Textures/7_of_diamonds.png', 'card_Textures/8_of_diamonds.png', 'card_Textures/9_of_diamonds.png',
            'card_Textures/10_of_diamonds.png', 'card_Textures/jack_of_diamonds2.png', 'card_Textures/queen_of_diamonds2.png', 'card_Textures/king_of_diamonds2.png',
            'card_Textures/ace_of_diamonds.png'];

        let spades = ['card_Textures/2_of_spades.png', 'card_Textures/3_of_spades.png', 'card_Textures/4_of_spades.png',
            'card_Textures/5_of_spades.png', 'card_Textures/6_of_spades.png', 'card_Textures/7_of_spades.png', 'card_Textures/8_of_spades.png',
            'card_Textures/9_of_spades.png', 'card_Textures/10_of_spades.png', 'card_Textures/jack_of_spades2.png', 'card_Textures/queen_of_spades2.png', 'card_Textures/king_of_spades2.png',
            'card_Textures/ace_of_spades.png'];

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.x = 0;
        camera.position.y = 2.5;
        camera.position.z = 4;

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);

        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        var focal = new THREE.Vector3(0.0, 0.0, 0.0);

        renderer.shadowMap.enabled = true;
        camera.lookAt(focal);
        scene.add(camera);

        const ambientLight = new THREE.AmbientLight(0xFFB6C1, .5);
        scene.add(ambientLight);

        //Src : https://threejs.org/examples/?q=light#webgl_lights_physical
        const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
        let bulbLight = new THREE.PointLight(0xffee88, 1.5, 100, 2);
        let bulbMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: 1,
            color: 0x000000
        });
        bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
        bulbLight.position.set(0, 2.0, -2);
        bulbLight.castShadow = true;
        scene.add(bulbLight);

        const rectLight = new THREE.RectAreaLight(0xADD8E6, intensity, width1, height1);
        rectLight.position.set(0, 0, -1.6);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        //left player 0, middle player 1. right player 2, we are player 1 in the middle
        // Src: 
        //https://dev.to/codebubb/how-to-shuffle-an-array-in-javascript-2ikj#:~:text=The%20first%20and%20simplest%20way,)%20%3D%3E%200.5%20%2D%20Math. 
        const shuffleArray = deck => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = deck[i];
                deck[i] = deck[j];
                deck[j] = temp;
            }
        }

        function Player(playerID, playerPosition) {
            this.cardsLeft = true;
            this.player = playerID;
            this.playerDeck = [];
            this.playing = true;
            this.currentCards = [];
            this.playerPos = playerPosition;
        }

        function Card(value, suit) {
            //Suit:
            //1 -- Spade
            //2 -- Hearts
            //3 -- Clubs
            //4 -- Diamonds
            this.cardValue = value;
            this.cardSuit = suit;

            this.geometry = new THREE.BoxGeometry(.3, .01, .6);
            this.material = makeMaterial(this.cardValue, this.cardSuit);

            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.rotation.x = 0;
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = true;
            this.mesh.translateY(5);

            scene.add(this.mesh);
        }

        function makeMaterial(value, suit) {
            const materials = [
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ map: loader.load(backOfCard) }), //this is the front
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }), //this is the back of the card
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
            ];
            let index = value - 1;
            let string;
            let material;
            if (suit == 1) { //Spade
                string = spades[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 2) { //Hearts
                string = hearts[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 3) { //Clubs
                string = clubs[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 4) { //Diamonds
                string = diamonds[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            return materials;
        }

        function initPlayers(number) {
            let player;
            for (let i = 0; i < number; i++) {
                player = new Player(i, positions[i]);
                players.push(player);
            }
        }

        function initCards() {
            let card;
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 1);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 2);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 3);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 4);
                deck.push(card);
            }
        }

        function initTable() {
            let string1 = 'misc_texures/table.png';
            let geometry = new THREE.BoxGeometry(3, .15, 3);
            let material = new THREE.MeshPhysicalMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(woodTexture),

            });
            tableMesh = new THREE.Mesh(geometry, material);
            tableMesh.receiveShadow = true;
            tableMesh.castShadow = true;

            scene.add(tableMesh);
        }

        function initGround() {
            let string1 = 'floor/floor7.jpg';
            let geometry = new THREE.BoxGeometry(.01, 20, 20);

            let grounds = [
                new THREE.MeshPhysicalMaterial({ map: loader.load(string1) }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }), //this is the front
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }), //this is the back of the card
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
            ];
            floorMesh = new THREE.Mesh(geometry, grounds);
            floorMesh.receiveShadow = true;
            floorMesh.castShadow = true;
            floorMesh.position.set(0, -3, -5);
            floorMesh.rotateZ(Math.PI / 2);
            camera.lookAt(floorMesh.position.x, floorMesh.position.y, floorMesh.position.z);

            scene.add(floorMesh);
        }

        function initHorizon() {
            let planeGeometry = new THREE.PlaneGeometry(2.5, 1.5);
            let planeMaterial = skies[1];
            let planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            planeMesh.position.set(0, .80, -1.7);
            scene.add(planeMesh);
            return planeMesh;
        }

        function initWall() {
            let wallPaperGeometry = new THREE.BoxGeometry(20, 5, 1);
            let wallPaperMaterial = new THREE.MeshPhysicalMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            let wallPaperMesh = new THREE.Mesh(wallPaperGeometry, wallPaperMaterial);
            wallPaperMesh.position.set(0, -3, -8);
            scene.add(wallPaperMesh);
        }

        function dealCards(deck, players) {
            shuffleArray(deck);
            for (let i = 0; i < deck.length; i++) {
                if (i <= 17) {
                    players[0].playerDeck.push(deck[i]);
                }
                else if (17 < i && i <= 34) {
                    players[1].playerDeck.push(deck[i]);
                }
                else if (i > 34) {
                    players[2].playerDeck.push(deck[i]);
                }
            }
            setOriginPosition(players);
            placeCards(players);
        }

        function placeCards(players) {
            let playerX;
            let playerY;
            let playerZ;
            for (let i = 0; i < players.length; i++) {
                let height = .075;
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    height += .013;
                    playerX = players[i].playerPos.x;
                    playerY = players[i].playerPos.y;
                    playerZ = players[i].playerPos.z;
                    players[i].playerDeck[x].mesh.position.set(playerX, playerY + height, playerZ);
                }
            }
        }
        function setOriginPosition(players) {
            for (let i = 0; i < players.length; i++) {
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    players[i].playerDeck[x].mesh.rotation.x = 0;
                    players[i].playerDeck[x].mesh.rotation.y = 0;
                    players[i].playerDeck[x].mesh.rotation.z = 0;
                }
            }
        }

        //Src: https://alvarotrigo.com/blog/wait-1-second-javascript/
        function delay(milliseconds) {
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        }

        function regularMove(players, warTime) {
            console.log("START REG MOVE");
            let cardsInPlay = getCardsInPlay(players);
            // console.log("CHICKEN BUTT ", cardsInPlay);
            moveUp(cardsInPlay, warTime);
        }

        //Src: https://alvarotrigo.com/blog/wait-1-second-javascript/
        async function moveUp(cards, warTime) {
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE UP");
                let card = cards[c];
                let i = 0;
                while (card.mesh.position.y <= .75) {
                    await delay(30);
                    card.mesh.translateY(.05); //.01
                    i++;
                }
                card.mesh.position.y = .75;
            }
            flip(cards, warTime);
        }

        async function flip(cards, warTime) {
            if (warTime == false) {
                for (let c = 0; c < cards.length; c++) {
                    console.log("START FLIP");
                    let card = cards[c];
                    let i = 0;
                    while (i < 15) { //30
                        await delay(15);
                        card.mesh.rotateZ(-.21); //-.105
                        i++;
                    }
                    card.mesh.rotation.z = -3.15;
                }
            }
            moveForward(cards, warTime);
        }

        async function moveForward(cards, warTime) {
            console.log("OH NO MY BOOLEAN ", warTime);
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE FORWARD");
                let card = cards[c];
                while (card.mesh.position.z <= .8) {
                    await delay(25);
                    card.mesh.translateZ(.05); //.05
                }
            }
            moveDown(cards, warTime);
        }

        async function moveDown(cards, warTime) {
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE DOWN");
                let card = cards[c];
                while (card.mesh.position.y >= cardPlacement) {
                    await delay(15);
                    if (warTime == false) {
                        card.mesh.translateY(.02);
                    }
                    else if (warTime == true) {
                        card.mesh.translateY(-.02);
                    }
                }
                card.mesh.position.y = cardPlacement;
            }
            cardPlacement += .015;
            console.log("animation done");
            findWinOrWar(cards);

            if (warTime == true) {
                moveOneCard(players);
                moveOneCard(players);
                regularMove(players, false);
            }
        }

        function findWinOrWar(cardsInPlay) {
            console.log("FIND RESULT");
            let wars = -10;
            let max = 0;
            for (let y = 0; y < cardsInPlay.length; y++) {
                if (cardsInPlay[y].cardValue == max) {
                    console.log("equal");
                    wars = max;
                }
                if (cardsInPlay[y].cardValue > max) {
                    console.log("greater");
                    max = cardsInPlay[y].cardValue;
                }
            }
            if (max == wars) {
                console.log("INTOWAR");
                if (checkPlayers(players) == true) {
                    moveOneCard(players);
                    regularMove(players, true);
                }
            }
            else if (max != wars) {
                console.log("FIND WINNER ");
                console.log("MAX IS ????? ", max);
                let winner;
                for (let i = 0; i < players.length; i++) {
                    if (players[i].playing == true) {
                        console.log("all player cards ", players[i].currentCards);
                        let card = players[i].currentCards[0];
                        console.log("CARD???  ", card);
                        if (card.cardValue == max) {
                            winner = players[i];
                        }
                    }
                }
                distributeWinnings(winner, players);
            }
        }

        function checkPlayers(players) {
            console.log("CHECK PLAYERS FUNC");
            let count = 0;
            for (let i = 0; i < players.length; i++) {
                if (players[i].playerDeck.length == 0) {
                    players[i].playing = false;
                    if (players[i].playing == false) {
                        count++;
                    }
                }
            }
            if (count == 2) {
                console.log("WINNER WINNER CHICKEN DINNER");
                for (let i = 0; i < players.length; i++) {
                    console.log("deck at the end ", players[i].playerDeck);
                }
                gameOver = true;
                return false;
            }
            else {
                return true;
            }
        }

        function moveOneCard(players) {
            console.log("MOVE ONE CARD FUNC");
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    if (players[i].playerDeck.length == 0) {
                        players[i].playing = false;
                    }
                    else {
                        let topCard = players[i].playerDeck.pop();
                        players[i].currentCards.unshift(topCard);
                    }
                }
            }
        }

        function getCardsInPlay(players) {
            console.log("START GET CARDS");
            let cardsInPlay = [];
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    cardsInPlay.push(players[i].currentCards[0]);
                    console.log("player current card ", players[i].currentCards[0]);
                }
            }
            return cardsInPlay;
        }

        function distributeWinnings(winner, players) {
            console.log("START DISTR WINNING");
            let spoils = [];
            for (let i = 0; i < players.length; i++) {
                spoils = spoils.concat(players[i].currentCards);
                players[i].currentCards = [];
            }
            console.log("spoils of war ", spoils);
            console.log("winner ", winner);
            for (let i = 0; i < spoils.length; i++) {
                winner.playerDeck.unshift(spoils[i]);
            }
            movePermitted = true;
        }

        function initMove(players) {
            console.log("HOT POTATO");
            if (checkPlayers(players) == true) {
                moveOneCard(players);
                regularMove(players, false);
            }
        }

        function keyHandler(e) {
            switch (e.keyCode) {
                case 87: //w
                    bulbLight.translateZ(-.1);
                    break;
                case 83: //s
                    bulbLight.translateZ(.1);
                    break;
                case 68: //d
                    bulbLight.translateX(.1);
                    break;
                case 65: //a
                    bulbLight.translateX(-.1);
                    break;
                case 76: //L
                    ambientLight.visible = !ambientLight.visible;
                    break;
                case 80: //P
                    bulbLight.visible = !bulbLight.visible;
                    bulbLight.position.set(0, .79, -2);
                    break;
                case 82: //R
                    rectLight.visible = !rectLight.visible;
                    break;
                case 77: //P
                    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
                    let enabled = renderer.shadowMap.enabled;

                    if (enabled == false) {
                        console.log("TURN OFF");
                        for (let i = 0; i < deck; i++) {
                            deck.mesh.castShadow = false;
                            deck.mesh.receiveShadow = false;
                        }
                        tableMesh.castShadow = false;
                        tableMesh.receiveShadow = false;
                        floorMesh.castShadow = false;
                        floorMesh.receiveShadow = false;
                    }
                    else {
                        console.log("TURN ON");
                        for (let i = 0; i < deck; i++) {
                            deck.mesh.castShadow = true;
                            deck.mesh.receiveShadow = true;
                        }
                        tableMesh.castShadow = true;
                        tableMesh.receiveShadow = true;
                        floorMesh.castShadow = true;
                        floorMesh.receiveShadow = true;
                    }
                    break;
                case 69:
                    if (sky0 == false) {
                        planeMesh.material = skies[0];
                        sky0 = true;
                    }
                    else {
                        planeMesh.material = skies[1];
                        sky0 = false;
                    }
                    break;
                case 78:
                    if (gameOver == false) {
                        if (movePermitted == true) {
                            cardPlacement = .08;
                            movePermitted = false;
                            placeCards(players);
                            setOriginPosition(players);
                            initMove(players);
                        }
                    }
            }
        }

        document.addEventListener("keydown", keyHandler, false);

        function animate() {
            updateSize();
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        //Src: https://threejs.org/examples/webgl_multiple_views.html
        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }

        initPlayers(3);
        initCards();
        initTable();
        initGround();
        initWall();
        let planeMesh = initHorizon();
        dealCards(deck, players);
        animate();
        renderer.render(scene, camera);

    </script>
</body>

</html>