<html>

<head>
    <title>Three.js BuffedGeometry Example</title>
</head>

<body>

    <canvas id="myCanvas" width="1650" height="700"></canvas>

    <script type="module">

        import * as THREE from "http://cs.merrimack.edu/~stuetzlec/three.js-master/build/three.module.js";
        import { FontLoader } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/src/loaders/FontLoader.js";
        import { TextGeometry } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/src/geometries/TextGeometry.js";
        import { RectAreaLight } from "http://cs.merrimack.edu/~stuetzlec/three.js-master/src/lights/RectAreaLight.js";

        var scene = new THREE.Scene();
        let windowWidth = window.innerWidth;
        let windowHeight = window.innerHeight;
        let deck = [];
        let tableMesh;
        let leftMid = new THREE.Vector3(-1.15, 0, 0);
        let rightMid = new THREE.Vector3(1.15, 0, 0);
        let centerMid = new THREE.Vector3(0, 0, 0);
        let positions = [leftMid, centerMid, rightMid];
        var enableWar = 0;
        var gameOver = false;
        let shadowCamera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        let players = [];
        let checkPlayerDecks = [];

        const width1 = 10;
        const height1 = 10;
        const intensity = 1;
        let movePermitted = true;

        const rectLight = new THREE.RectAreaLight(0xffffff, intensity, width1, height1);
        rectLight.position.set(0, 0, -1.6);
        rectLight.lookAt(0, 0, 0);
        scene.add(rectLight);

        let text = 'three.js',
            bevelEnabled = true,
            font = undefined,
            fontName = 'optimer', // helvetiker, optimer, gentilis, droid sans, droid serif
            fontWeight = 'bold'; // normal bold

        const height = 20,
            size = 70,
            hover = 30,
            curveSegments = 4,
            bevelThickness = 2,
            bevelSize = 1.5;

        const mirror = true;

        const fontMap = {
            'helvetiker': 0,
            'optimer': 1,
            'gentilis': 2,
            'droid/droid_sans': 3,
            'droid/droid_serif': 4
        };

        const weightMap = {
            'regular': 0,
            'bold': 1
        };

        let woodTexture = 'misc_textures/table.jpg';
        let backOfCard = 'misc_textures/card_back.png';

        let clubs = ['card_Textures/2_of_clubs.png', 'card_Textures/3_of_clubs.png', 'card_Textures/4_of_clubs.png', 'card_Textures/5_of_clubs.png',
            'card_Textures/6_of_clubs.png', 'card_Textures/7_of_clubs.png', 'card_Textures/8_of_clubs.png', 'card_Textures/9_of_clubs.png',
            'card_Textures/10_of_clubs.png', 'card_Textures/jack_of_clubs2.png', 'card_Textures/queen_of_clubs2.png',
            'card_Textures/king_of_clubs2.png', 'card_Textures/ace_of_clubs.png'];

        let hearts = ['card_Textures/2_of_hearts.png', 'card_Textures/3_of_hearts.png', 'card_Textures/4_of_hearts.png', 'card_Textures/5_of_hearts.png',
            'card_Textures/6_of_hearts.png', 'card_Textures/7_of_hearts.png', 'card_Textures/8_of_hearts.png', 'card_Textures/9_of_hearts.png',
            'card_Textures/10_of_hearts.png', 'card_Textures/jack_of_hearts2.png', 'card_Textures/queen_of_hearts2.png', 'card_Textures/king_of_hearts2.png',
            'card_Textures/ace_of_hearts.png'];
        
            let diamonds = ['card_Textures/2_of_diamonds.png', 'card_Textures/3_of_diamonds.png', 'card_Textures/4_of_diamonds.png',
            'card_Textures/5_of_diamonds.png', 'card_Textures/6_of_diamonds.png', 'card_Textures/7_of_diamonds.png', 'card_Textures/8_of_diamonds.png', 'card_Textures/9_of_diamonds.png',
            'card_Textures/10_of_diamonds.png', 'card_Textures/jack_of_diamonds2.png', 'card_Textures/queen_of_diamonds2.png', 'card_Textures/king_of_diamonds2.png',
            'card_Textures/ace_of_diamonds.png'];
       
            let spades = ['card_Textures/2_of_spades.png', 'card_Textures/3_of_spades.png', 'card_Textures/4_of_spades.png',
            'card_Textures/5_of_spades.png', 'card_Textures/6_of_spades.png', 'card_Textures/7_of_spades.png', 'card_Textures/8_of_spades.png',
            'card_Textures/9_of_spades.png', 'card_Textures/10_of_spades.png', 'card_Textures/jack_of_spades2.png', 'card_Textures/queen_of_spades2.png', 'card_Textures/king_of_spades2.png',
            'card_Textures/ace_of_spades.png'];

        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.x = 0;  // Try moving this around!
        camera.position.y = 2.5;
        camera.position.z = 4;  // Try moving this around!

        var renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
        renderer.setClearColor(0x000000);
        // If you want this to span the window, instead of using the myCanvas object, use the window object
        renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight); //Sets the size of the renderer to the entirety of the
        var focal = new THREE.Vector3(0.0, 0.0, 0.0);

        renderer.shadowMap.enabled = true;//shadow
        let shadowEnabled = true;

        camera.lookAt(focal);
        scene.add(camera);


        // #FFC0CB
        //0x0000ff
        const ambientLight = new THREE.AmbientLight(0xFF66CC, 1); // soft white light
        scene.add(ambientLight);

        const bulbGeometry = new THREE.SphereGeometry(0.02, 16, 8);
        let bulbLight = new THREE.PointLight(0xffee88, 1.5, 100, 2);
        let bulbMat = new THREE.MeshStandardMaterial({
            emissive: 0xffffee,
            emissiveIntensity: 1,
            color: 0x000000
        });
        bulbLight.add(new THREE.Mesh(bulbGeometry, bulbMat));
        bulbLight.position.set(0, 2.5, -2);

        bulbLight.castShadow = true;//shadow

        scene.add(bulbLight);

        // shadowCamera.position.x = bulbLight.position.x;
        // shadowCamera.position.y = bulbLight.position.y;
        // shadowCamera.position.z = bulbLight.position.z;
        // console.log(shadowCamera.position);


        const loader = new THREE.TextureLoader();
        const geometry = new THREE.BoxGeometry(.2, .01, .4);

        //let i = 0;

        //left player 0, middle player 1. right player 2, we are player 1 in the middle
        const shuffleArray = deck => {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = deck[i];
                deck[i] = deck[j];
                deck[j] = temp;
            }
        }

        function Player(playerID, playerPosition) {
            this.cardsLeft = true;
            this.player = playerID;
            this.playerDeck = [];
            this.playing = true;
            this.currentCards = [];
            this.playerPos = playerPosition;
        }

        function Card(value, suit) {
            //Suit:
            //1 -- Spade
            //2 -- Hearts
            //3 -- Clubs
            //4 -- Diamonds
            this.cardValue = value;
            this.cardSuit = suit;

            this.geometry = new THREE.BoxGeometry(.3, .01, .6);
            this.material = makeMaterial(this.cardValue, this.cardSuit);

            this.mesh = new THREE.Mesh(this.geometry, this.material);
            this.mesh.rotation.x = 0;
            this.mesh.castShadow = true;
            this.mesh.receiveShadow = true;
            this.mesh.translateY(5);

            console.log(this.mesh, 'mesh check shadow');


            scene.add(this.mesh);
        }

        function makeMaterial(value, suit) {
            const materials = [

                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ map: loader.load(backOfCard) }), //this is the front
                new THREE.MeshPhysicalMaterial({ map: loader.load(backOfCard) }), //this is the back of the card
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff }),
            ];

            let index = value - 1;
            let string;
            let material;

            if (suit == 1) { //Spade
                string = spades[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 2) { //Hearts
                string = hearts[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 3) { //Clubs
                string = clubs[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            else if (suit == 4) { //Diamonds
                string = diamonds[index];
                material = new THREE.MeshPhysicalMaterial({
                    // Use the map attribute to hold the texture
                    map: loader.load(string),
                });
                materials[3] = material;
            }
            //console.log(material);
            return materials;
        }

        function initCards() {
            let card;

            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 1);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 2);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 3);
                deck.push(card);
            }
            for (let i = 1; i <= 13; i++) {
                card = new Card(i, 4);
                deck.push(card);
            }
        }

        function initPlayers(number) {
            let player;
            for (let i = 0; i < number; i++) {
                player = new Player(i, positions[i]);
                players.push(player);
            }
            checkPlayerDecks = players;
        }

        function testShape() {
            let geom = new THREE.BoxGeometry(.25, .25, .25);
            let material = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            let mesh = new THREE.Mesh(geom, material);
            mesh.position.set(0, 0, 0);
            scene.add(mesh);
            return mesh;
        }

        //  testShape();


        function initTable() {
            let string1 = 'misc_texures/table.png';
            let geometry = new THREE.BoxGeometry(3, .15, 3);
            let material = new THREE.MeshPhysicalMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(woodTexture),

            });
            tableMesh = new THREE.Mesh(geometry, material);
            tableMesh.receiveShadow = true;//shadow
            tableMesh.castShadow = true;

            console.log(tableMesh, 'mesh');
            scene.add(tableMesh);
        }

        function initWindow() {
            let string1 = 'windows/window6.jpg';
            let windowgeometry = new THREE.BoxGeometry(2.2, 1.3, .02);

            let windowMaterial = new THREE.MeshBasicMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),

            });
            let windowMesh = new THREE.Mesh(windowgeometry, windowMaterial);

            windowMesh.position.set(0, 0, -3.7);
            // windowMesh.receiveShadow = true;//shadow
            // windowMesh.castShadow = true;

            console.log('window', windowMesh);

            scene.add(windowMesh);
        }

        let floorMesh;

        function initGround() {
            let string1 = 'floor/floor7.jpg';
            let geometry = new THREE.BoxGeometry(.01, 20, 20);
            let material = new THREE.MeshPhysicalMaterial({
                // Use the map attribute to hold the texture
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1),
                map: loader.load(string1)

            });
            floorMesh = new THREE.Mesh(geometry, material);
            floorMesh.receiveShadow = true;//shadow
            floorMesh.castShadow = true;

            floorMesh.position.set(0, -3, -5);

            floorMesh.rotateZ(Math.PI / 2);
            //floorMesh.rotateY(Math.PI*2);
            //floorMesh.rotation.x=-4.17;


            camera.lookAt(floorMesh.position.x, floorMesh.position.y, floorMesh.position.z);

            console.log(floorMesh, 'mesh');
            scene.add(floorMesh);


        }

        function initHorizon() {
            let planeGeometry = new THREE.PlaneGeometry(2.5, 1.5);
            let planeMaterial = new THREE.MeshBasicMaterial({ map: loader.load('skylines/sky2.jpg'), side: THREE.DoubleSide });
            let planeMesh = new THREE.Mesh(planeGeometry, planeMaterial);
            //planeMesh.rotateX(1);
            scene.add(planeMesh);
            planeMesh.position.set(0, .80, -1.7);
        }

        function initWall() {
            let wallPaperGeometry = new THREE.BoxGeometry(20, 5, 1);
            let wallPaperMaterial = new THREE.MeshBasicMaterial({ map: loader.load('wallpaper/wallpaper7.jpg'), side: THREE.DoubleSide });
            let wallPaperMesh = new THREE.Mesh(wallPaperGeometry, wallPaperMaterial);
            //planeMesh.rotateX(1);
            //wallPaperMesh.rotateY(Math.PI/2);
            // wallPaperMesh.castShadow=true;
            // wallPaperMesh.receiveShadow=true;
            scene.add(wallPaperMesh);
            wallPaperMesh.position.set(0, -3, -8);
        }


        function dealCards(deck, players) {
            shuffleArray(deck);
            for (let i = 0; i < deck.length; i++) {
                if (i <= 17) {
                    players[0].playerDeck.push(deck[i]);
                }
                else if (17 < i && i <= 34) {
                    players[1].playerDeck.push(deck[i]);
                }
                else if (i > 34) {
                    players[2].playerDeck.push(deck[i]);
                }
            }

            setOriginPosition(players);

            // rotateCards(players[2]);
            console.log("player id to rotate", players[0].player);
            console.log("player id to rotate", players[2].player);
            console.log("card placement, ", players[1].playerDeck[0].mesh.position);
            placeCards(players);
        }


        function placeCards(players) {
            let playerX;
            let playerY;
            let playerZ;
            for (let i = 0; i < players.length; i++) {
                let height = .075;
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    height += .013;
                    playerX = players[i].playerPos.x;
                    playerY = players[i].playerPos.y;
                    playerZ = players[i].playerPos.z;
                    //  console.log(players[i].playerDeck[x]);
                    players[i].playerDeck[x].mesh.position.set(playerX, playerY + height, playerZ);
                    // players[i].playerPos = new THREE.Vector3(playerX, playerY, lastHeight+.1);
                }
            }

        }

        function setOriginPosition(players) {
            for (let i = 0; i < players.length; i++) {
                for (let x = 0; x < players[i].playerDeck.length; x++) {
                    players[i].playerDeck[x].mesh.rotation.x = 0;
                    players[i].playerDeck[x].mesh.rotation.y = 0;
                    players[i].playerDeck[x].mesh.rotation.z = 0;
                }
            }
        }

        function regularMove(players, warTime) {
            console.log("START REG MOVE");
            let cardsInPlay = getCardsInPlay(players);
            console.log("CHICKEN BUTT ", cardsInPlay);
            moveUp(cardsInPlay, warTime);

            // for (let i = 0; i < players.length; i++) {
            //     console.log("card passed into moveup ", players[i].currentCards[0]);
            //     moveUp(players[i].currentCards[0]);
            // }

            //moveOneCard(players);

            //  flip(card);
            // moveForward(card);
            // moveDown(card, -1);
            //    let cardsInPlay = getCardsInPlay(players);
            //     findWinOrWar(cardsInPlay);
        }


        // function tempWarMove(players) {
        //     console.log("in temp war?");
        //     if (checkPlayers(players) == true) {
        //         moveOneCard(players);
        //         regularMove(players);
        //         moveOneCard(players);
        //         regularMove(players);
        //         // for (let i = 0; i < players.length; i++){
        //         //     regularMove(players[i].currentCards[0]);
        //         // }
        //     }
        //     // for (let i = 0; i < players.length; i++) {
        //     //    // moveUpWar(players[i].currentCards[0]);
        //     // }

        //     //moveOneCard(players);

        //     //  flip(card);
        //     // moveForward(card);
        //     // moveDown(card, -1);
        //     //    let cardsInPlay = getCardsInPlay(players);
        //     //     findWinOrWar(cardsInPlay);
        // }



        // function warMove(players) {
        //     console.log("START WAR MOVE");
        //     //moveUp(card);
        //     //moveForward(card);
        //     // moveDown(card, -1);
        //     //  moveOneCard(players);
        //     regularMove(players);

        // }



        function delay(milliseconds) {
            return new Promise(resolve => {
                setTimeout(resolve, milliseconds);
            });
        }

        async function moveUp(cards, warTime) {
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE UP");
                let card = cards[c];
                let i = 0;
                while (card.mesh.position.y <= .75) {
                    await delay(1);
                    card.mesh.translateY(.05); //.01
                    i++;
                }
                card.mesh.position.y = .75;
            }
          
            flip(cards, warTime);
        }

        async function flip(cards, warTime) {
            if (warTime == false) {
                for (let c = 0; c < cards.length; c++) {
                    console.log("START FLIP");
                    let card = cards[c];
                    let i = 0;
                    while (i <15) { //30
                        await delay(1);
                        
                       // console.log(card.mesh.rotation.z, 'card rotation before');
                        card.mesh.rotateZ(-.21); //-.105
                        
                        //console.log(card.mesh.rotation.z, 'card rotation after');
                        i++;
                    }
                    card.mesh.rotation.z = -3.15;
                }
              
            }

            moveForward(cards, warTime);
        }

        async function moveForward(cards, warTime) {
            console.log("OH NO MY BOOLEAN ", warTime);
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE FORWARD");
                let card = cards[c];
                while (card.mesh.position.z <= .8) {
                    await delay(1);
                    card.mesh.translateZ(.1); //.05
                }
            }
                moveDown(cards, warTime);
        }

        async function moveDown(cards, warTime) {
            for (let c = 0; c < cards.length; c++) {
                console.log("START MOVE DOWN");
                let card = cards[c];
                while (card.mesh.position.y >= .08) {
                    await delay(1);
                    if (warTime == false) {
                        console.log("card moving .04 with but not wartime", warTime);
                        card.mesh.translateY(.02);
                    }
                    else if (warTime == true) {
                        console.log("card moving -.04 in wartime");
                        card.mesh.translateY(-.02);
                    }
                }
                card.mesh.position.y = .08;
            }
            console.log("animation done");
            findWinOrWar(cards);
            console.log("movedown");
           
            if (warTime == true) {
                
                moveOneCard(players);
                regularMove(players, false);
             
                // movePermitted=false;
            }
             
              
            // let cardsInPlay = getCardsInPlay(players);
            // findWinOrWar(cardsInPlay);
            
        }


        //in: array of players [0.1.2]
        //out: num players left
        function checkPlayers(players) {
            console.log("CHECK PLAYERS FUNC");
            let count = 0;

            for (let i = 0; i < players.length; i++) {
                // console.log(i, " player deck ", players[i].playerDeck.length);
                if (players[i].playerDeck.length == 0) {
                    players[i].playing = false;
                    if (players[i].playing == false) {
                        count++;
                    }
                }
            }

            if (count == 2) {
                console.log("WINNER WINNER CHICKEN DINNER");
                for (let i = 0; i < players.length; i++) {
                    console.log("deck at the end ", players[i].playerDeck);
                }
                gameOver = true;
                return false;
            }
            else {
                return true;
            }

        }

        //in player
        //out nothing
        function moveOneCard(players) {
            console.log("MOVE ONE CARD FUNC");
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    if (players[i].playerDeck.length == 0) {
                        players[i].playing = false;
                    }
                    else {
                        let topCard = players[i].playerDeck.pop();
                        players[i].currentCards.unshift(topCard);
                    }
                }
            }
        }

        //in: players array
        //out: an array of playing cards [1.2.3]
        function getCardsInPlay(players) {
            console.log("START GET CARDS");
            let cardsInPlay = [];
            for (let i = 0; i < players.length; i++) {
                if (players[i].playing == true) {
                    cardsInPlay.push(players[i].currentCards[0]);
                    console.log("player current card ", players[i].currentCards[0]);
                    // tryMoveVertical(players[i].currentCards[0], -1);
                    // tryFlip(players[i].currentCards[0]);
                    //tryMoveForward(players[i].currentCards[0]);
                    // moveUp(players[i].player, players[i].currentCards[0]);
                    //players[i].currentCards[0].mesh.translateY(.5);

                }
            }
            //toggleMovement();

            return cardsInPlay;
        }


        //in: array [1,2,3] 
        //out: max
        function findWinOrWar(cardsInPlay) {
            console.log("FIND RESULT");
            let wars = -10;
            let max = 0;
            for (let y = 0; y < cardsInPlay.length; y++) {
                //  console.log("war: ", wars);
                //console.log("max: ", max);
                //console.log("card ", cardsInPlay[y].cardValue);
                //console.log("check ", cardsInPlay[y]);
                if (cardsInPlay[y].cardValue == max) {
                    console.log("equal");
                    wars = max;
                }
                if (cardsInPlay[y].cardValue > max) {
                    console.log("greater");
                    // console.log("greater");
                    max = cardsInPlay[y].cardValue;
                }
                // console.log("missed both");
            }

            if (max == wars) {
                console.log("INTOWAR");
                if (checkPlayers(players) == true) {
                    moveOneCard(players);
                    //tempWarMove(players);
                    regularMove(players, true);

                }
            }
            else if (max != wars) {
                console.log("FIND WINNER ");
                console.log("MAX IS ????? ", max);
                let winner;
                for (let i = 0; i < players.length; i++) {
                    if (players[i].playing == true) {
                        let card = players[i].currentCards[0];
                        console.log("CARD???  ", card);
                        if (card.cardValue == max) {
                            winner = players[i];
                        }
                    }
                }
                distributeWinnings(winner, players);
                //Console.log("GIVE SPOILS");
                //distributeWinnings(winner, players);
                //placeCards(players);
                //setOriginPosition(players)
            }


            // console.log("max is ", max);
            //return max;
        }


        //in: players
        //out: none
        function distributeWinnings(winner, players) {
            console.log("START DISTR WINNING");
            let spoils = [];
            for (let i = 0; i < players.length; i++) {
                spoils = spoils.concat(players[i].currentCards);
                players[i].currentCards = [];

            }
            console.log("spoils of war ", spoils);
            console.log("winner ", winner);
            for (let i = 0; i < spoils.length; i++) {
                winner.playerDeck.unshift(spoils[i]);
            }
            movePermitted=true;
        }


        function hotPotato(players) {
            console.log("HOT POTATO");
            if (checkPlayers(players) == true) {
                moveOneCard(players);
                regularMove(players, false);
                // for (let i = 0; i < players.length; i++){
                //     regularMove(players[i].currentCards[0]);
                // }
            }
        }




        function makeMove(players, isThisWar) {
            let check = checkPlayers(players);
            if (check == true) {
                if (isThisWar == false) {
                    moveOneCard(players);
                }
                else {
                    moveOneCard(players);
                    moveOneCard(players);
                }

                let cards = getCardsInPlay(players);
                let state = findWinOrWar(cards);
                if (state == -1) {
                    console.log("War has begun");
                    makeMove(players, true);
                }
                else {
                    let winner;
                    for (let i = 0; i < players.length; i++) {
                        if (players[i].playing == true) {
                            let card = players[i].currentCards[0];
                            console.log("card in distribute ", card);
                            if (card.cardValue == state) {
                                winner = players[i];
                            }
                        }
                    }
                    distributeWinnings(winner, players);
                    //placeCards(players);


                    for (let i = 0; i < players.length; i++) {
                        if (players[i].playing == true) {
                            //  setOriginPosition(players);
                            console.log(i, " player deck length ", players[i].playerDeck.length);
                        }

                    }
                }
            }
            else {
                let winner;
                for (let i = 0; i < players.length; i++) {
                    if (players[i].player == true) {
                        winner = players[i].player;
                    }
                }
                distributeWinnings(winner, players);
                placeCards(players);
                console.log("one player remains");
            }
        }


        function animate() {
            updateSize();

            //    floorMesh.rotateX(.03);
            //    console.log(floorMesh.rotation.x);


            requestAnimationFrame(animate);
            render();
        }

        function render() {
            renderer.render(scene, camera);
        }

        function updateSize() {
            if (windowWidth != window.innerWidth || windowHeight != window.innerHeight) { //If the window width or height has
                //actually been changed than this if statement is triggered
                windowWidth = window.innerWidth;
                windowHeight = window.innerHeight;
                renderer.setSize(windowWidth, windowHeight);
            }
        }


        function keyHandler(e) {
            switch (e.keyCode) {
                case 87: //w
                    bulbLight.translateZ(-.1);
                    break;
                case 83: //s
                    bulbLight.translateZ(.1);
                    break;
                case 68: //d
                    bulbLight.translateX(.1);
                    break;
                case 65: //a
                    bulbLight.translateX(-.1);
                    break;
                case 76: //L
                    ambientLight.visible = !ambientLight.visible;
                    break;
                case 80: //P
                    //placeCards(players);
                    bulbLight.visible = !bulbLight.visible;
                    bulbLight.position.set(0, .79, -2);
                    break;
                case 82: //R
                    //placeCards(players);
                    rectLight.visible = !rectLight.visible;
                    break;
                case 77: //P
                    renderer.shadowMap.enabled = !renderer.shadowMap.enabled;
                    let enabled = renderer.shadowMap.enabled;

                    if (enabled == false) {
                        console.log("TURN OFF");
                        for (let i = 0; i < deck; i++) {
                            deck.mesh.castShadow = false;
                            deck.mesh.receiveShadow = false;
                        }
                        tableMesh.castShadow = false;
                        tableMesh.receiveShadow = false;
                    }
                    else {
                        console.log("TURN ON");
                        for (let i = 0; i < deck; i++) {
                            deck.mesh.castShadow = true;
                            deck.mesh.receiveShadow = true;
                        }
                        tableMesh.castShadow = true;
                        tableMesh.receiveShadow = true;
                    }
                    break;
                case 78:

                if (gameOver == false) {
                    if (movePermitted==true){
                        movePermitted=false;
                        placeCards(players);
                        setOriginPosition(players)
                        // toggleMovement();
                        // makeMove(players, false);
                        hotPotato(players);
                    }
                    // else {
                    //  //   console.log("u dumbass");
                    // }
                      
                        
                    }
            }
        }


        document.addEventListener("keydown", keyHandler, false);


        initTable();
        initCards();
        initHorizon();
        initGround();
        initWall();
        initWindow();
        initPlayers(3);
        dealCards(deck, players);
        console.log(players);

        animate();

        renderer.render(scene, camera);
    </script>
</body>

</html>